% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dtrackr.R
\name{p_slice_max}
\alias{p_slice_max}
\title{Slice operations}
\usage{
p_slice_max(
  .data,
  ...,
  .messages = c("{.count.in} before", "{.count.out} after"),
  .headline = "slice data"
)
}
\arguments{
\item{.data}{A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See \emph{Methods}, below, for
more details.}

\item{...}{
  Arguments passed on to \code{\link[dplyr:slice]{dplyr::slice_max}}
  \describe{
    \item{\code{n,prop}}{Provide either \code{n}, the number of rows, or \code{prop}, the
proportion of rows to select. If neither are supplied, \code{n = 1} will be
used. If \code{n} is greater than the number of rows in the group
(or \code{prop > 1}), the result will be silently truncated to the group size.
\code{prop} will be rounded towards zero to generate an integer number of
rows.

A negative value of \code{n} or \code{prop} will be subtracted from the group
size. For example, \code{n = -2} with a group of 5 rows will select 5 - 2 = 3
rows; \code{prop = -0.25} with 8 rows will select 8 * (1 - 0.25) = 6 rows.}
    \item{\code{order_by}}{<\code{\link[rlang:args_data_masking]{data-masking}}> Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.}
    \item{\code{with_ties}}{Should ties be kept together? The default, \code{TRUE},
may return more rows than you request. Use \code{FALSE} to ignore ties,
and return the first \code{n} rows.}
    \item{\code{na_rm}}{Should missing values in \code{order_by} be removed from the result?
If \code{FALSE}, \code{NA} values are sorted to the end (like in \code{\link[dplyr:arrange]{arrange()}}), so
they will only be included if there are insufficient non-missing values to
reach \code{n}/\code{prop}.}
  }}

\item{.messages}{a set of glue specs. The glue code can use any global
variable, \{.count.in\}, \{.count.out\} for the input and output dataframes
sizes respectively and \{.excluded\} for the difference}

\item{.headline}{a glue spec. The glue code can use any global variable,
\{.count.in\}, \{.count.out\} for the input and output dataframes sizes
respectively.}
}
\value{
the sliced dataframe with the history graph updated.
}
\description{
Slice operations behave as in dplyr, except the history graph can be updated with
tracked dataframe with the before and after sizes of the dataframe.
See \code{\link[dplyr:slice]{dplyr::slice()}}, \code{\link[dplyr:slice]{dplyr::slice_head()}}, \code{\link[dplyr:slice]{dplyr::slice_tail()}},
\code{\link[dplyr:slice]{dplyr::slice_min()}}, \code{\link[dplyr:slice]{dplyr::slice_max()}}, \code{\link[dplyr:slice]{dplyr::slice_sample()}},
for more details on the underlying functions.
}
\examples{
library(dplyr)
library(dtrackr)


# Subset the data by the maximum of a given value
iris \%>\% track() \%>\% group_by(Species) \%>\%
  slice_max(prop=0.5, order_by = Sepal.Width,
            .messages="{.count.out} / {.count.in} = {prop} (with ties)",
            .headline="Widest 50\% Sepals") \%>\%
  history()


# The narrowest 25\% of the iris data set by group can be calculated in the
# slice_min() function. Recording this is a matter of tracking and
# using glue specs.
iris \%>\%
  track() \%>\%
  group_by(Species) \%>\%
  slice_min(prop=0.25, order_by = Sepal.Width,
            .messages="{.count.out} / {.count.in} (with ties)",
            .headline="narrowest {sprintf('\%1.0f',prop*100)}\% {Species}") \%>\%
  history()

}
\seealso{
dplyr::slice_max()
}
