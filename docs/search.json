[{"path":"https://terminological.github.io/dtrackr/index.html/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing","title":"Contributing","text":"contributing repository, please first discuss change wish make via issue, email, method owners repository making change. Please note code conduct, please follow interactions project.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/CONTRIBUTING.html","id":"submitting-changes-and-raising-issues","dir":"","previous_headings":"","what":"Submitting changes and raising issues","title":"Contributing","text":"aim respond comments issues, keep update development plans . Offers help always welcome. reporting issue please try reproduce using one data sets ’ve used vignettes (e.g. iris, diamonds, mtcars, survival::cgd ) include data set issue. can also tell us exactly text expect see flowchart isn’t , helpful. Please fork code send GitHub Pull Request clear list ’ve done (read pull requests).","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/CONTRIBUTING.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"Contributing","text":"’d love help better test cases. testing dtrackr uses testthat framework. configured run unit tests functional tests code examples. Github workflows enabled repository continuous integration. perform R CMD check code commits, run testthat unit tests, run man page examples, build vignettes. vignette building dependencies tidyverse package, well system libraries required vignette building pandoc. CI tests check library can installed macOs, windows, Ubuntu, R versions 3.6.1, 4.1, 4.2 R development branch. tagged releases, additional Github workflows triggered r-universe repository, build binary releases range platforms.","code":"# assuming dtrackr has been cloned from github into the working directory  # location  devtools::load_all()  # Long list of system dependencies in Ubuntu 20.04 including all suggested  # dependencies: # librsvg2-dev libicu-dev libcurl4-openssl-dev libssl-dev libnode-dev make  # pandoc imagemagick libmagick++-dev gsfonts default-jdk libxml2-dev  # zlib1g-dev libfontconfig1-dev libfreetype6-dev libfribidi-dev libharfbuzz-dev  # libjpeg-dev libpng-dev libtiff-dev git libgit2-dev  pak::local_system_requirements(\"ubuntu\",\"20.04\") install.packages(c(\"here\",\"tidyverse\",\"devtools\",\"testthat\",\"pkgdown\"))  # Examples: devtools::run_examples()  # automated testing with testthat (also runs all examples): devtools::test()  # pkgdown site building (which executes all the vignettes): pkgdown::build_site()"},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/CONTRIBUTING.html","id":"our-pledge","dir":"","previous_headings":"Code of Conduct","what":"Our Pledge","title":"Contributing","text":"interest fostering open welcoming environment, contributors maintainers pledge making participation project community harassment-free experience everyone, regardless age, body size, disability, ethnicity, gender identity expression, level experience, nationality, personal appearance, race, religion, sexual identity orientation.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/CONTRIBUTING.html","id":"our-standards","dir":"","previous_headings":"Code of Conduct","what":"Our Standards","title":"Contributing","text":"Examples behaviour contributes creating positive environment include: Using welcoming inclusive language respectful differing viewpoints experiences Gracefully accepting constructive criticism Focusing best community Showing empathy towards community members Examples unacceptable behavior participants include: use sexualized language imagery unwelcome sexual attention advances Trolling, insulting/derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical electronic address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/CONTRIBUTING.html","id":"our-responsibilities","dir":"","previous_headings":"Code of Conduct","what":"Our Responsibilities","title":"Contributing","text":"Project maintainers responsible clarifying standards acceptable behavior expected take appropriate fair corrective action response instances unacceptable behavior. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, ban temporarily permanently contributor behaviors deem inappropriate, threatening, offensive, harmful.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/CONTRIBUTING.html","id":"scope","dir":"","previous_headings":"Code of Conduct","what":"Scope","title":"Contributing","text":"Code Conduct applies within project spaces public spaces individual representing project community. Examples representing project community include using official project e-mail address, posting via official social media account, acting appointed representative online offline event. Representation project may defined clarified project maintainers.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/CONTRIBUTING.html","id":"enforcement","dir":"","previous_headings":"Code of Conduct","what":"Enforcement","title":"Contributing","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported contacting project team rob@terminological.co.uk. complaints reviewed investigated result response deemed necessary appropriate circumstances. project team obligated maintain confidentiality regard reporter incident. details specific enforcement policies may posted separately. Project maintainers follow enforce Code Conduct good faith may face temporary permanent repercussions determined members project’s leadership.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/CONTRIBUTING.html","id":"attribution","dir":"","previous_headings":"Code of Conduct","what":"Attribution","title":"Contributing","text":"Code Conduct adapted Contributor Covenant, version 1.4, available http://contributor-covenant.org/version/1/4","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Robert Challen Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/articles/consort-example.html","id":"consort-statement","dir":"Articles","previous_headings":"","what":"CONSORT statement","title":"dtrackr - Consort statement example","text":"CONSORT diagrams part requirements reporting parallel group clinical trials case control designs observational studies. described updated 2010 CONSORT statement (Schulz, Altman, Moher 2010). clarify patients recruited, selected, randomised followed . observational studies equivalent requirement STROBE statement (von Elm et al. 2008). similar requirements types study TRIPOD statement applicable multivariate models (Collins et al. 2015). demonstration use cgd data set survival package (Terry M. Therneau Patricia M. Grambsch 2000; Therneau 2022), placebo controlled trial gamma interferon Chronic Granulomatous Disease. example treatment column contains intervention. analysis considering first observations patient, study criteria follows: patients US based centres considered Patients must steroids inception. Patients must aged ages 5 35 inclusive. can coded dplyr pipeline, additional dtrackr functions: bit experimentation flowchart needed STROBE/CONSORT checklist can generated. One option output flowchart svg can manually formatted required, publication ready output pdf usually preferred.","code":"# Some useful formatting options old = options(   dtrackr.strata_glue=\"{tolower(.value)}\",   dtrackr.strata_sep=\", \",   dtrackr.default_message = \"{.count} records\",   dtrackr.default_headline = NULL )  demo_data = survival::cgd %>%    track() %>%   filter(enum == 1, .type=\"inclusion\", .messages=\"{.count.out} first observation\") %>%   include_any(     hos.cat == \"US:NIH\" ~ \"{.included} NIH patients\",     hos.cat == \"US:other\" ~ \"{.included} other US patients\"   ) %>%   group_by(treat, .messages=\"cases versus controls\") %>%   comment() %>%   capture_exclusions() %>%   exclude_all(     age<5 ~ \"{.excluded} subjects under 5\",     age>35 ~ \"{.excluded} subjects over 35\",     steroids == 1 ~ \"{.excluded} on steroids at admission\"   ) %>%   comment(.messages = \"{.count} after exclusions\") %>%   status(     mean_height = sprintf(\"%1.2f \\u00B1 %1.2f\",mean(height),sd(height)),     mean_weight = sprintf(\"%1.2f \\u00B1 %1.2f\",mean(weight),sd(weight)),     .messages = c(       \"average height: {mean_height}\",       \"average weight: {mean_weight}\"     )                       ) %>%   ungroup(.messages = \"{.count} in final data set\")  # restore to originals options(old) demo_data %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/consort-example.html","id":"excluded-data","dir":"Articles","previous_headings":"","what":"Excluded data","title":"dtrackr - Consort statement example","text":"pipeline, may keen understand certain data items rejected. enable us examine source data, potentially correct data collection process. ’ve used allow continuous quality checks data feed back data curators, regularly conduct analyses. tracking exclusions, track data flow pipeline also retain excluded items, reason exclusion. Thus can reassure exclusions expected. enabled calling capture_exclusions() pipeline . tracked exclusions can retrieve calling excluded() gives data frame excluded records reasons. exclusions happened multiple stages dataframe format change held nested dataframe (.e. see ?tidyr::nest): list may multiple entries single data item, example something excluded one step many reasons.","code":"# here we filter out the majority of the actual content of the excluded data to focus on the  # metadata recovered during the exclusion. demo_data %>% excluded() %>% select(.stage,.message,.filter,age, steroids) #> # A tibble: 15 × 5 #>    .stage  .message                   .filter       age   steroids #>    <chr>   <glue>                     <chr>         <chr> <chr>    #>  1 stage 1 7 subjects under 5         age < 5       2     0        #>  2 stage 1 7 subjects under 5         age < 5       1     0        #>  3 stage 1 7 subjects under 5         age < 5       1     0        #>  4 stage 1 7 subjects under 5         age < 5       1     0        #>  5 stage 1 7 subjects under 5         age < 5       1     0        #>  6 stage 1 7 subjects under 5         age < 5       4     0        #>  7 stage 1 7 subjects under 5         age < 5       3     0        #>  8 stage 1 4 subjects under 5         age < 5       3     0        #>  9 stage 1 4 subjects under 5         age < 5       4     0        #> 10 stage 1 4 subjects under 5         age < 5       1     0        #> 11 stage 1 4 subjects under 5         age < 5       4     0        #> 12 stage 1 3 subjects over 35         age > 35      44    0        #> 13 stage 1 3 subjects over 35         age > 35      38    0        #> 14 stage 1 3 subjects over 35         age > 35      37    0        #> 15 stage 1 1 on steroids at admission steroids == 1 6     1"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/consort-example.html","id":"tagging-the-pipeline","dir":"Articles","previous_headings":"","what":"Tagging the pipeline","title":"dtrackr - Consort statement example","text":"reporting results useful numbers flowchart embed text results section write . show pipeline , 4 uses .tag system labelling part pipeline. captures data tag-value list pipeline, retains metadata later reuse. tagged data can retrieved follows, give tagged data 4 points pipeline: often though want retrieve specific values specific points results text example: example 128 patients study, 74 patients met eligibility criteria. complex formatting calculations made possible use glue specification, including happen per group basis, can also pull values elsewhere analysis. Sometimes necessary operate tagged content . possible aware content available depends somewhat tag set pipeline fields always present (although .count .total ). .total overall number cases point pipeline. .count number cases strata. comparing inclusions exclusions different stages pipeline using tags following example may useful:","code":"demo_data = survival::cgd %>%    track(.messages = NULL) %>%   filter(enum == 1, .type=\"inclusion\", .messages=\"{.count.out} first observation\") %>%   comment(.tag = \"initial cohort\") %>%   #         ^^^^^^^^^^^^^^^^^^^^^   #         TAGS DEFINED      include_any(     hos.cat == \"US:NIH\" ~ \"{.included} NIH patients\",     hos.cat == \"US:other\" ~ \"{.included} other US patients\"   ) %>%   group_by(treat, .messages=\"cases versus controls\") %>%    comment(.tag=\"study cohort\") %>%   #       ^^^^^^^^^^^^^^^^^^^   #       SECOND SET OF TAGS DEFINED      capture_exclusions() %>%   exclude_all(     age<5 ~ \"{.excluded} subjects under 5\",     age>35 ~ \"{.excluded} subjects over 35\",     steroids == 1 ~ \"{.excluded} on steroids at admission\"   ) %>%      comment(.messages = \"{.count} after exclusions\") %>%      status(     mean_height = sprintf(\"%1.2f \\u00B1 %1.2f\",mean(height),sd(height)),     mean_weight = sprintf(\"%1.2f \\u00B1 %1.2f\",mean(weight),sd(weight)),     .messages = c(       \"average height: {mean_height}\",       \"average weight: {mean_weight}\"     ),     .tag = \"qualifying patients\"   #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   #  THIRD SET TAGS DEFINED                       ) %>%   ungroup(.messages = \"{.count} in final data set\", .tag=\"final set\")   #                                                 ^^^^^^^^^^^^^^^^   #                                                 LAST TAGS DEFINED demo_data %>% tagged() %>% tidyr::unnest(.content) #> # A tibble: 6 × 7 #>   .tag                .count .total .strata        treat mean_height mean_weight #>   <chr>                <int>  <int> <chr>          <fct> <chr>       <chr>       #> 1 initial cohort         128    128 \"\"             NA    NA          NA          #> 2 study cohort            43     89 \"treat:placeb… plac… NA          NA          #> 3 study cohort            46     89 \"treat:rIFN-g\" rIFN… NA          NA          #> 4 qualifying patients     36     74 \"treat:placeb… plac… 145.58 ± 2… 45.46 ± 23… #> 5 qualifying patients     38     74 \"treat:rIFN-g\" rIFN… 143.14 ± 2… 40.70 ± 20… #> 6 final set               74     74 \"\"             NA    NA          NA initialSet = demo_data %>% tagged(.tag = \"initial cohort\", .glue = \"{.count} patients\") finalSet = demo_data %>% tagged(.tag = \"final set\", .glue = \"{.count} patients\")  # there were `r initialSet` in the study, of whom `r finalSet` met the eligibility criteria. demo_data %>% tagged(     .tag = \"qualifying patients\",      .glue = \"{.strata}: {.count}/{.total} ({sprintf('%1.1f', .count/.total*100)}%) patients on {sysDate}, with a mean height of {mean_height}\",      sysDate = Sys.Date()     # we could have included any number of other parameters here from the global environment   ) %>% dplyr::pull(.label) #> treat:placebo: 36/74 (48.6%) patients on 2024-10-19, with a mean height of 145.58 ± 29.10 #> treat:rIFN-g: 38/74 (51.4%) patients on 2024-10-19, with a mean height of 143.14 ± 25.12 demo_data %>% tagged(.glue = \"{.count}/{.total} patients\") #> # A tibble: 6 × 3 #>   .tag                .strata         .label           #>   <chr>               <chr>           <glue>           #> 1 initial cohort      \"\"              128/128 patients #> 2 study cohort        \"treat:placebo\" 43/89 patients   #> 3 study cohort        \"treat:rIFN-g\"  46/89 patients   #> 4 qualifying patients \"treat:placebo\" 36/74 patients   #> 5 qualifying patients \"treat:rIFN-g\"  38/74 patients   #> 6 final set           \"\"              74/74 patients demo_data %>%    tagged() %>%   # selects only top level content   tidyr::unnest(.content) %>%    dplyr::select(.tag, .total) %>%    dplyr::distinct() %>%   tidyr::pivot_wider(values_from=.total, names_from=.tag) %>%    glue::glue_data(\"Out of {`initial cohort`} patients, {`study cohort`} were eligible for inclusion on the basis of their age   but {`study cohort`-`qualifying patients`} were outside the age limits.    This left {`final set`} patients included in the final study (i.e. overall {`initial cohort`-`final set`} were removed).\") #> Out of 128 patients, 89 were eligible for inclusion on the basis of their age #> but 15 were outside the age limits.  #> This left 74 patients included in the final study (i.e. overall 54 were removed)."},{"path":"https://terminological.github.io/dtrackr/index.html/articles/consort-example.html","id":"reusable-functions","dir":"Articles","previous_headings":"","what":"Reusable functions","title":"dtrackr - Consort statement example","text":"Composing dtrackr inclusion exclusion criteria functions lets reuse across different studies, useful functions need parametrised. dtrackr uses formulae specify inclusion exclusion criteria, construct appropriate formulae dtrackr using values parametrised helper function requires injection support, using rlang::inject(). advanced R topic following example gives sense possible.","code":"# This is a reusable function to restrict ages age_restrict = function(df, age_col, min_age = 18, max_age = 65) {   age_col = rlang::ensym(age_col)   message = sprintf(\"{.included} between\\n%d and %d years\", min_age, max_age)   dtrackr::include_any(df,     # injection support for parameters must be made explicit using     # rlang::inject in any functions using include_any or exclude_all     rlang::inject(min_age <= !!age_col & max_age >= !!age_col ~ !!message)   ) }  survival::cgd %>%    # the `age` column is in the cgd dataset:    age_restrict(age, max_age = 30) %>%   # demonstrating that this works in 2 stages   age_restrict(age, min_age = 20) %>%    flowchart()"},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr-options.html","id":"global-configuration","dir":"Articles","previous_headings":"","what":"Global configuration","title":"dtrackr - Configuration example","text":"behaviour dtrackr can specified individual call level using .headline .messages glue specifications define format. Sometimes however annoying stages flow chart global configuration behaviour desirable.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr-options.html","id":"naming-conventions-for-groups","dir":"Articles","previous_headings":"Global configuration","what":"Naming conventions for groups","title":"dtrackr - Configuration example","text":"One areas default behaviour may undesirable naming groups. default setting combines group name {.group} group value {.value} concatenated colon separated string demonstrated : particular situations like faceting factors strings, disposing group name may make clearer. following example include group value, force lower case, use comma separate multiple facets. used manual override messages grouping stages, providing .messages parameter, specify faceting natural way: N.B. setting affects “strata” label group, turn affects flowchart branching. unique one group another strange behaviours observed.","code":"# these are the defaults old = options(   dtrackr.strata_glue=\"{.group}:{.value}\",   dtrackr.strata_sep=\"; \" )  survival::cgd %>%   track() %>%   group_by(treat) %>%   comment() %>%   group_by(sex,.add = TRUE) %>%   comment(     .messages = c(     \"{.count} patients\",     \"{sprintf('%1.0f',.count/.total*100)}% of the total\")) %>%   ungroup() %>%   flowchart() # reset options  options(old) # only include the group value in the description of the group old = options(   dtrackr.strata_glue=\"{tolower(.value)}\",   dtrackr.strata_sep=\", \" )  survival::cgd %>%   track() %>%   group_by(treat, .messages = \"case or control\") %>%   comment() %>%   group_by(sex,     .add = TRUE,      .messages = \"by {tolower(.cols)}\" #.cols contains a csv string of the grouping variables   ) %>%   comment(     .messages = c(     \"{.count} patients\",     \"{sprintf('%1.0f',.count/.total*100)}% of the total\")) %>%   ungroup() %>%   flowchart() # reset options  options(old)"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr-options.html","id":"default-text","dir":"Articles","previous_headings":"Global configuration","what":"Default text","title":"dtrackr - Configuration example","text":"group strata label defined can set defaults. flowchart “583 items” labels generated default message setting, headings groups default headline setting. example change alter default text.","code":"old = options(   dtrackr.strata_glue=\"{tolower(.value)}\",   dtrackr.strata_sep=\", \",   dtrackr.default_message = \"containing {.count} patients\",   dtrackr.default_headline = \"subgroup: {.strata}\" )  survival::cgd %>%   track() %>%   group_by(     treat,     .messages = \"case or control\"   ) %>%   comment() %>%   group_by(     sex,     .add = TRUE,      .messages = \"by gender\"   ) %>%   comment(     .messages = c(     \"{.count} patients\",     \"{sprintf('%1.0f',.count/.total*100)}% of the total\")) %>%   ungroup() %>%   flowchart() # N.b. this setting includes some unwanted headlines in the ungrouped stages of # the flow chart. If a headline evaluates to \"\" then the headline is suppressed # and we can get rid of unwanted headlines. An example of doing this is as # follows: # options(dtrackr.default_headline = \"{ifelse(.strata != '', glue::glue('subgroup: {.strata}'), '')}\")  # reset options  options(old)"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr-options.html","id":"subgroup-count","dir":"Articles","previous_headings":"Global configuration","what":"Subgroup count","title":"dtrackr - Configuration example","text":"Subgroup counts slightly neater way . default layout can modified using dtrackr.default_count_subgroup.","code":"old = options(   dtrackr.default_headline = \"{.strata}\",   dtrackr.default_count_subgroup = \"{tolower(.name)}: {.count}/{.subtotal}\" )  survival::cgd %>%   track() %>%   group_by(     treat,     .messages = \"case or control\"   ) %>%   comment() %>%   count_subgroup(     sex   ) %>%   ungroup() %>%   flowchart() # reset options  options(old)"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr-options.html","id":"exclusions","dir":"Articles","previous_headings":"Global configuration","what":"Exclusions","title":"dtrackr - Configuration example","text":"Elsewhere discuss possibility capturing excluded items debugging. behaviour can added pipeline capture_exclusions() function. Alternatively can globally enabled following option. Usual caveats performance apply.","code":"options(dtrackr.exclusions=TRUE)"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr-options.html","id":"reporting-exclusions-which-do-nothing","dir":"Articles","previous_headings":"Global configuration","what":"Reporting exclusions which do nothing","title":"dtrackr - Configuration example","text":"Sometimes pipeline exclusion criteria triggered, triggered particular subgroup. case default show zero items excluded. However sometimes reassuring know filter applied even results nothing:","code":"options(dtrackr.show_zero_exclusions=FALSE)"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr-options.html","id":"maximum-groupings","dir":"Articles","previous_headings":"Global configuration","what":"Maximum groupings","title":"dtrackr - Configuration example","text":"count_subgroup() group_by() statements can large number items generated particular grouping variable lot possible values. can cause performance issues legibility issues resulting graph usually result interim stage data pipeline grouping used fine scale summarisation operation (e.g. dataset %>% group_by(nearly_unique_id) %>% filter(row_number()==1) time-series things need aggregated date, data quickly ungrouped (e.g. timeseries %>% group_by(date) %>% summarise(count = n())). number groups dtrackr attempt keep track configurable defaults 16:","code":"options(dtrackr.max_supported_groupings = 16)"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr-options.html","id":"verbose-output","dir":"Articles","previous_headings":"Global configuration","what":"Verbose output","title":"dtrackr - Configuration example","text":"Various messages dtrackr produced suppressed default. can enabled following flag.","code":"options(dtrackr.verbose=TRUE)"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr.html","id":"tracking-data-provenance","dir":"Articles","previous_headings":"","what":"Tracking data provenance","title":"dtrackr - Basic operations","text":"wrangling complex data sets form suitable analysis may many steps transformations filtering data performed data pipeline. stage want reassure removed data done right reasons, scientific publication need communicate processing data undergone, whether data processing unevenly affects groups wish compare. frequently updated analyses must automated. dtrackr provides generic capability can address problems. extending normal data manipulation functions provided dplyr, allow operations dataframe recorded metadata, dataframe passes data pipeline, “history graph”. can export history graph flowchart helps documentation, makes accurate reporting scientific literature simpler. Tracking data pipeline also allows us way capture data excluded, see visual summary detailed line list exclusions. can help identifying rectifying data quality issues. situation data analysed interactively, pipeline code created, tracking history dataframe, visualising , allows us identify data manipulated way intend, helps debug pipeline code, uncover unsupported assumptions data. places tracking data provenance also help, visualising steps individual data item takes pipeline can compare different data, new versions data sets, quickly validate data pipeline use new data.","code":"# devtools::load_all() library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(dtrackr) #>  #> Attaching package: 'dtrackr' #> The following objects are masked from 'package:dplyr': #>  #>     add_tally, bind_cols, bind_rows #> The following object is masked from 'package:stats': #>  #>     filter #> The following object is masked from 'package:utils': #>  #>     history #> The following object is masked from 'package:base': #>  #>     comment"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr.html","id":"basic-operation---comments-and-stratification","dir":"Articles","previous_headings":"","what":"Basic operation - comments and stratification","title":"dtrackr - Basic operations","text":"main documentation data pipelines provided comment function. (functions) uses glue package specification define comment text. glue specification can use range variables describe data passes pipeline. Firstly can use global variables filename example. Secondly .count variable number rows current group. Thirdly .strata variable defined description group(s) currently , grouped data grouping variables (case Species) can also used. Finally .total variable returns whole size ungrouped data-set. Comments can either single .headline list .messages. Setting either “” disables given comment. example, thanks glue, expression can evaluated messages warned, debugging hard. error glue spec present dtrackr try tell problem variables available glue spec. (N.B. common mistake use .message rather .messages providing glue spec.)","code":"# devtools::load_all() filename = \"~/tmp/iris.csv\" # this is just a pretend example # iris = read.csv(filename)   iris %>%   track(     .headline = \"Iris data:\",     .messages = c(       \"loaded from \\\"{filename}\\\"\",       \"starts with {.count} items\")   ) %>%   group_by(Species) %>%   comment(     .headline = \"{.strata}\",     .messages = c(     \"In {Species}\",     \"there are {.count} items\",     \"that is {sprintf('%1.0f',.count/.total*100)}% of the total\"),     .tag = \"note1\"     ) %>%   ungroup() %>%   comment(\"Final data has {.total} items\", .tag=\"note2\") %>%     flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr.html","id":"status---further-analysis-in-the-workflow","dir":"Articles","previous_headings":"","what":"Status - Further analysis in the workflow","title":"dtrackr - Basic operations","text":"middle pipeline may wish document something data complex simple counts. comment sophisticated counterpart status. status essentially dplyr summarisation step connected glue specification output, recorded data frame history. plain English means can arbitrary summarisation put result flowchart, without interrupting data flow, example: frequent use case detailed description subgroup count within flowchart. different enough function count_subgroup(). works best factor subgroup columns data converted factor automatically. uses glue specifications modified formatted output also possible example, subgroup percentages calculated 1 decimal place.","code":"iris %>%   track(\"starts with {.count} items\") %>%   group_by(Species) %>%   status(     petalMean = sprintf(\"%1.1f\", mean(Petal.Width)),     petalSd = sprintf(\"%1.1f\", sd(Petal.Width)),     .messages = c(     \"In {Species} the petals are\",     \"on average {petalMean} \\u00B1 {petalSd} cms wide\")) %>%   ungroup(.messages = \"ends with {.total} items\") %>%   flowchart() ggplot2::diamonds %>%   track() %>%   group_by(cut) %>%   count_subgroup(     color,     .messages = \"colour {.name}: {sprintf('%1.1f%%', {.count}/{.subtotal}*100)}\"   ) %>%   ungroup() %>%   flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr.html","id":"filtering-exclusions-and-inclusions","dir":"Articles","previous_headings":"","what":"Filtering, exclusions and inclusions","title":"dtrackr - Basic operations","text":"Documenting data set useful can also manipulate , one part including excluding things don’t want. standard dplyr::filter approach works , can use .count..count., difference two .excluded document result . example exclude items one standard deviation mean. default message (.messages = \"excluded {.excluded} items\") left simply returns many things excluded. customization goal pipeline look much possible like dplyr pipeline possible take normal dplyr pipeline insert track() front flowchart() end get documented pipeline. useful reason exclusion clear like, scale particularly well multiple criteria, typical filters needed massage real life data. written exclude_all takes multiple criteria applies parallel, combining result end, documenting individual effects. Rather logical expression expected dplyr::filter provide matching criteria formula relating filtering criteria left hand side, glue specification right hand side (trick inspired dplyr::case_when()’s syntax). much slower filter gives fine control output. logic exclude_all() reversed compared dplyr::filter(). filter() items filtering criteria TRUE INCLUDED. example missing values, however behaviour filter() criteria evaluated NA values generated exclude . exclude_all() can multiple criteria items match criteria EXCLUDED. particular criteria evaluated data item behaviour exclude_all() controlled na.rm parameter. defaults FALSE means values evaluated excluded. different criteria number items excluded recorded history graph manner defined right hand side exclusion criteria formulae. Exclusions produced like additive items may excluded one exclusion criteria, list exclusion counts won’t necessarily add exclusion total. Sometimes inclusion criteria important. use include_any works similar manner INCLUDING items match supplied criteria, essentially combining criteria logical operation, case resulting different result previous example.","code":"iris %>%   track() %>%   group_by(Species) %>%   filter(     Petal.Width < mean(Petal.Width)+sd(Petal.Width)   ) %>%   ungroup() %>%   flowchart() dataset1 = iris %>%   track() %>%   comment(\"starts with {.count} items\") %>%   exclude_all(     Species==\"versicolor\" ~ \"removing {.excluded} versicolor\"   ) %>%   group_by(Species) %>%   comment(\"{Species} has {.count} items\") %>%   exclude_all(     Petal.Width > mean(Petal.Width)+sd(Petal.Width) ~ \"{.excluded} with petals > 1 SD wider than the mean\",     Petal.Length > mean(Petal.Length)+sd(Petal.Length) ~ \"{.excluded} with petals > 1 SD longer than the mean\",     Sepal.Width > mean(Sepal.Width)+sd(Sepal.Width) ~ \"{.excluded} with sepals > 1 SD wider than the mean\",     Sepal.Length > mean(Sepal.Length)+sd(Sepal.Length) ~ \"{.excluded} with sepals > 1 SD longer than the mean\"   ) %>%   comment(\"{Species} now has {.count} items\") %>%   ungroup() %>%   comment(\"ends with {.total} items\")  dataset1 %>% flowchart() dataset2 = iris %>%   track() %>%   comment(\"starts with {.count} items\") %>%   include_any(     Species==\"versicolor\" ~ \"{.included} versicolor\",     Species==\"setosa\" ~ \"{.included} setosa\"   ) %>%   #mutate(Species = forcats::fct_drop(Species)) %>%   group_by(Species) %>%   comment(\"{Species} has {.count} items\") %>%   include_any(     Petal.Width < mean(Petal.Width)+sd(Petal.Width) ~ \"{.included} with petals <= 1 SD wider than the mean\",     Petal.Length < mean(Petal.Length)+sd(Petal.Length) ~ \"{.included} with petals <= 1 SD longer than the mean\",     Sepal.Width < mean(Sepal.Width)+sd(Sepal.Width) ~ \"{.included} with sepals <= 1 SD wider than the mean\",     Sepal.Length < mean(Sepal.Length)+sd(Sepal.Length) ~ \"{.included} with sepals <= 1 SD longer than the mean\"   ) %>%   comment(\"{Species} now has {.count} items\") %>%   ungroup() %>%   comment(\"ends with {.total} items\")    dataset2 %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr.html","id":"excluded-data","dir":"Articles","previous_headings":"","what":"Excluded data","title":"dtrackr - Basic operations","text":"considering data pipeline sometimes important know excluded stage. can help debugging addressing data quality issues. dtrackr can collect data excluded time history graph, along record pipeline item excluded. behaviour enabled capture_exclusions() flag. Give previous data pipeline can identify items excluded, stage pipeline excluded details code resulted excluded.","code":"tmp = iris %>%   track() %>%    capture_exclusions() %>%   exclude_all(     Petal.Length > 5.8 ~ \"{.excluded} long ones\",     Petal.Length < 1.3 ~ \"{.excluded} short ones\",     .stage = \"petal length exclusion\"   ) %>%   comment(\"leaving {.count}\") %>%   group_by(Species) %>%   filter(     Sepal.Length >= quantile(Sepal.Length, 0.05),     .messages=\"removing {.count.in-.count.out} with sepals < q 0.05\",     .type = \"comment\",     .stage = \"sepal length exclusion\"   ) %>%   comment(\"leaving {.count}\") %>%   exclude_all(     Petal.Width < 0.2 ~ \"{.excluded} narrow ones\",     Petal.Width > 2.1 ~ \"{.excluded} wide ones\"   ) %>%   comment(\"leaving {.count}\")  tmp %>% flowchart() tmp %>% excluded() #> # A tibble: 40 × 9 #>    .stage     .strata .message Sepal.Length Sepal.Width Petal.Length Petal.Width #>    <chr>      <chr>   <glue>   <chr>        <chr>       <chr>        <chr>       #>  1 petal len… \"\"      13 long… 6.3          3.3         6            2.5         #>  2 petal len… \"\"      13 long… 7.1          3           5.9          2.1         #>  3 petal len… \"\"      13 long… 7.6          3           6.6          2.1         #>  4 petal len… \"\"      13 long… 7.3          2.9         6.3          1.8         #>  5 petal len… \"\"      13 long… 7.2          3.6         6.1          2.5         #>  6 petal len… \"\"      13 long… 7.7          3.8         6.7          2.2         #>  7 petal len… \"\"      13 long… 7.7          2.6         6.9          2.3         #>  8 petal len… \"\"      13 long… 7.7          2.8         6.7          2           #>  9 petal len… \"\"      13 long… 7.2          3.2         6            1.8         #> 10 petal len… \"\"      13 long… 7.4          2.8         6.1          1.9         #> # ℹ 30 more rows #> # ℹ 2 more variables: Species <chr>, .filter <chr>"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr.html","id":"advanced-handling-of-the-history-graph-","dir":"Articles","previous_headings":"","what":"Advanced handling of the history graph.","title":"dtrackr - Basic operations","text":"history graph stored attribute tracked dataframe. contents attribute list dataframes including edge list node list. can imported graph processing packages, visualised different ways. Alternatively used automated testing data pipelines, example. GraphViz language provides many options formatting flowchart. Rather try provide interface , gone sane defaults. want change use different layout engine GraphViz output can retrieved edited directly. Alternatively output need different, rendered SVG output can edited hand.","code":"tmp2 = tmp %>% p_get()  # the nodes, .id is a graph unique identifier tmp2$nodes %>% glimpse() #> Rows: 16 #> Columns: 6 #> $ .id     <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 #> $ .rank   <dbl> 1, 1, 2, 3, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6 #> $ .strata <chr> \"\", \"\", \"\", \"\", \"Species:setosa\", \"Species:versicolor\", \"Speci… #> $ .label  <chr> \"150 items<BR ALIGN='LEFT'/>\", \"13 long ones<BR ALIGN='LEFT'/>… #> $ .type   <chr> \"info\", \"exclusion\", \"info\", \"stratify\", \"comment\", \"comment\",… #> $ .stage  <chr> \"\", \"petal length exclusion\", \"\", \"\", \"sepal length exclusion\"…  # the edges, .to and .from are foreign keys for .id tmp2$edges %>% glimpse() #> Rows: 15 #> Columns: 5 #> $ .to          <dbl> 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 #> $ .from        <dbl> 1, 1, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10, 8, 9, 10 #> $ .rel         <chr> \"exclusion\", \"info\", \"stratify\", \"comment\", \"comment\", \"c… #> $ .strata      <chr> \"\", \"\", \"\", \"Species:setosa\", \"Species:versicolor\", \"Spec… #> $ .strata.prev <chr> \"\", \"\", \"\", \"\", \"\", \"\", \"Species:setosa\", \"Species:versic… cat(tmp %>% p_get_as_dot()) #> digraph { #>      graph [layout = 'dot', #>         splines='ortho', #>         rankdir = 'TB', #>         outputorder = 'edgesfirst', #>         bgcolor = 'white', #>         ranksep = '0.25', #>         nodesep = '0.2', #>         newrank='true'] #>  #>     node [fontname = 'Helvetica', #>         fontsize = '8', #>         shape='box', #>         fixedsize = 'false', #>         margin = '0.1,0.1', #>         width = '0', #>         height = '0', #>         style = 'filled', #>         color = 'black', #>         fontcolor = 'black', #>         labeljust='l'] #>  #>     edge [fontname = 'Helvetica', #>         fontsize = '8', #>         len = '0.5', #>         color = 'black', #>         arrowsize = '0.5'] #>      #> { rank='same'; #> '14' [label=<<B>Species:setosa<\/B><BR ALIGN='LEFT'/>leaving 39<BR ALIGN='LEFT'/>>,group='Species:setosa',fillcolor='white']; #> '15' [label=<<B>Species:versicolor<\/B><BR ALIGN='LEFT'/>leaving 47<BR ALIGN='LEFT'/>>,group='Species:versicolor',fillcolor='white']; #> '16' [label=<<B>Species:virginica<\/B><BR ALIGN='LEFT'/>leaving 24<BR ALIGN='LEFT'/>>,group='Species:virginica',fillcolor='white']; #> } #> { rank='same'; #> '8' [label=<<B>Species:setosa<\/B><BR ALIGN='LEFT'/>leaving 43<BR ALIGN='LEFT'/>>,group='Species:setosa',fillcolor='white']; #> '9' [label=<<B>Species:versicolor<\/B><BR ALIGN='LEFT'/>leaving 47<BR ALIGN='LEFT'/>>,group='Species:versicolor',fillcolor='white']; #> '10' [label=<<B>Species:virginica<\/B><BR ALIGN='LEFT'/>leaving 35<BR ALIGN='LEFT'/>>,group='Species:virginica',fillcolor='white']; #> '11' [label=<<B>Species:setosa<\/B><BR ALIGN='LEFT'/>4 narrow ones<BR ALIGN='LEFT'/>0 wide ones<BR ALIGN='LEFT'/>>,group='Species:setosa',fillcolor='grey80']; #> '12' [label=<<B>Species:versicolor<\/B><BR ALIGN='LEFT'/>0 narrow ones<BR ALIGN='LEFT'/>0 wide ones<BR ALIGN='LEFT'/>>,group='Species:versicolor',fillcolor='grey80']; #> '13' [label=<<B>Species:virginica<\/B><BR ALIGN='LEFT'/>0 narrow ones<BR ALIGN='LEFT'/>11 wide ones<BR ALIGN='LEFT'/>>,group='Species:virginica',fillcolor='grey80']; #> } #> { rank='same'; #> '5' [label=<<B>Species:setosa<\/B><BR ALIGN='LEFT'/>removing 3 with sepals &lt; q 0.05<BR ALIGN='LEFT'/>>,group='Species:setosa',fillcolor='white']; #> '6' [label=<<B>Species:versicolor<\/B><BR ALIGN='LEFT'/>removing 3 with sepals &lt; q 0.05<BR ALIGN='LEFT'/>>,group='Species:versicolor',fillcolor='white']; #> '7' [label=<<B>Species:virginica<\/B><BR ALIGN='LEFT'/>removing 2 with sepals &lt; q 0.05<BR ALIGN='LEFT'/>>,group='Species:virginica',fillcolor='white']; #> } #> { rank='same'; #> '4' [label=<stratify by Species<BR ALIGN='LEFT'/>>,group='',fillcolor='white']; #> } #> { rank='same'; #> '3' [label=<leaving 133<BR ALIGN='LEFT'/>>,group='',fillcolor='white']; #> } #> { rank='same'; #> '1' [label=<150 items<BR ALIGN='LEFT'/>>,group='',fillcolor='white']; #> '2' [label=<13 long ones<BR ALIGN='LEFT'/>4 short ones<BR ALIGN='LEFT'/>>,group='',fillcolor='grey80']; #> } #>  #>  #> '10' -> '16' [tailport='s',weight='100'] #> '9' -> '15' [tailport='s',weight='100'] #> '8' -> '14' [tailport='s',weight='100'] #> '10' -> '13' [tailport='e',weight='1'] #> '9' -> '12' [tailport='e',weight='1'] #> '8' -> '11' [tailport='e',weight='1'] #> '7' -> '10' [tailport='s',weight='100'] #> '6' -> '9' [tailport='s',weight='100'] #> '5' -> '8' [tailport='s',weight='100'] #> '4' -> '7' [tailport='s',weight='100'] #> '4' -> '6' [tailport='s',weight='100'] #> '4' -> '5' [tailport='s',weight='100'] #> '3' -> '4' [tailport='s',weight='100'] #> '1' -> '3' [tailport='s',weight='100'] #> '1' -> '2' [tailport='e',weight='1'] #> }"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/dtrackr.html","id":"combined-data-flows","dir":"Articles","previous_headings":"","what":"Combined data flows","title":"dtrackr - Basic operations","text":"Data sets undergo different processing may joined single dataset. supported dtrackr demonstrated “joining-pipelines” vignette.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/articles/joining-pipelines.html","id":"joins-across-data-sets","dir":"Articles","previous_headings":"","what":"Joins across data sets","title":"dtrackr - Joining data pipelines","text":"Joining dtrackr tracked data supported allows us combine linked data sets. toy example data sets characters popular film youth. dplyr join types supported dtrackr allows us report numbers either side join resulting total. can help detect data items lost join. However yet capture data becomes excluded joins, interpretation depends type join employed.","code":"# here we create a set of linked data from the starwars data # in a real example these data sets would have come from different places people = starwars %>% select(-films, -vehicles, -starships) vehicles = starwars %>% select(name,vehicles) %>% unnest(cols = c(vehicles)) starships = starwars %>% select(name,starships) %>% unnest(cols = c(starships)) films = starwars %>% select(name,films) %>% unnest(cols = c(films)) # these 4 data frames are linked together by the name attribute  # we track both input data sets: tmp1 = people %>% track() %>% comment(\"People df {.total}\") tmp2 = films %>% track() %>% comment(\"Films df {.total}\") %>% comment(\"a test comment\")  # and here we (re)join the two data sets: tmp1 %>%    inner_join(tmp2, by=\"name\") %>%    comment(\"joined {.total}\") %>%    flowchart() # The join message used by inner_join here is configurable but defaults to  # {.count.lhs} on LHS # {.count.rhs} on RHS # {.count.out} in linked set"},{"path":"https://terminological.github.io/dtrackr/index.html/articles/joining-pipelines.html","id":"unions","dir":"Articles","previous_headings":"","what":"Unions","title":"dtrackr - Joining data pipelines","text":"Another type binary operator union. simpler problem works expected. example early part pipeline detected branches data flow. therefore results flow splits subsequently joins union (bind_rows) operator. dplyr set operations supported setdiff(), union(), union_all() intersect() included function documentation.","code":"tmp = people %>% comment(\"start\")  tmp1 = tmp %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\"   )  tmp2 = tmp %>% include_any(   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans\")  tmp3 = bind_rows(tmp1,tmp2) %>% comment(\"{.count} human,droids and gungans\")  tmp3 %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robert Challen. Author, maintainer.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Challen R (2022). “dtrackr: R package tracking provenance data.” Journal Open Source Software. doi:10.21105/joss.04707, R package version 0.2.5, https://joss.theoj.org/papers/10.21105/joss.04707.","code":"@Article{,   title = {dtrackr: An R package for tracking the provenance of data},   year = {2022},   note = {R package version 0.2.5},   url = {https://joss.theoj.org/papers/10.21105/joss.04707},   doi = {10.21105/joss.04707},   journal = {Journal of Open Source Software},   author = {Robert Challen}, }"},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Track your Data Pipelines","text":"Accurate documentation data pipeline first step reproducibility, flow chart describing steps taken prepare data useful part documentation. analyses rely data frequently updated, documenting data flow copying pasting row counts flowcharts PowerPoint becomes quickly tedious. interactive data analysis, particularly using RMarkdown, code execution sometimes happens non-linear fashion, can lead , best, confusion worst erroneous analysis. Basing documentation code executed sequentially can inaccurate data analysed interactively. goal dtrackr take away pain instrumenting monitoring dataframe dplyr pipeline, creating step--step summary important parts wrangling actually happened dataframe, right dataframe metadata . metadata can used generate documentation flowchart, allows quick overview data also visual check actual data processing.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Track your Data Pipelines","text":"general use dtrackr expected installed alongside tidyverse set packages. recommended install tidyverse first. Binary packages dtrackr available CRAN r-universe macOS Windows. dtrackr can installed source Linux. dtrackr tested R versions 3.6, 4.0, 4.1 4.2. can install released version dtrackr CRAN :","code":"install.packages(\"dtrackr\")"},{"path":"https://terminological.github.io/dtrackr/index.html/index.html","id":"system-dependencies-for-installation-from-source","dir":"","previous_headings":"Installation","what":"System dependencies for installation from source","title":"Track your Data Pipelines","text":"installation source Linux, dtrackr required transitive dependencies system libraries. can installed following commands:","code":"# Ubuntu 20.04 and other debian based distributions: sudo apt-get install libcurl4-openssl-dev libssl-dev librsvg2-dev \\   libicu-dev libnode-dev libpng-dev libjpeg-dev libpoppler-cpp-dev  # Centos 8 sudo dnf install libcurl-devel openssl-devel librsvg2-devel \\   libicu-devel libpng-devel libjpeg-turbo-devel poppler-devel  # for other linux distributions I suggest using the R pak library: # install.packages(\"pak\") # pak::pkg_system_requirements(\"dtrackr\")  # N.B. There are additional suggested R package dependencies on  # the `tidyverse` and `rstudioapi` packages which have a longer set of dependencies.  # We suggest you install them individually first if required."},{"path":"https://terminological.github.io/dtrackr/index.html/index.html","id":"alternative-versions-of-dtrackr","dir":"","previous_headings":"Installation","what":"Alternative versions of dtrackr","title":"Track your Data Pipelines","text":"Early release versions available r-universe. typically date CRAN. unstable development version available GitHub :","code":"# Enable repository from terminological options(repos = c(   terminological = 'https://terminological.r-universe.dev',   CRAN = 'https://cloud.r-project.org')) # Download and install dtrackr in R install.packages('dtrackr') # install.packages(\"devtools\") devtools::install_github(\"terminological/dtrackr\")"},{"path":"https://terminological.github.io/dtrackr/index.html/index.html","id":"example-usage","dir":"","previous_headings":"","what":"Example usage","title":"Track your Data Pipelines","text":"Suppose constructing data set initial input iris data. analysis depends cutOff parameter want prepare stratified data set excludes flowers narrow petals, biggest petals Species. dtrackr can mix regular dplyr commands additional dtrackr commands comment status, enhanced implementation dplyr::filter, called exclude_all, include_any. prepared dataset conduct analysis, want write prepare submission. key part documenting data pipeline visual summary useful, bio-medical journals clinical trials often requirement.  publication ready data pipeline, assumptions care document, creates format choice (long choice one pdf, png, svg ps), ready submission Nature. trivial example, complex pipeline, bigger benefit get. Check main documentation details, particular getting started vignette.","code":"# a pipeline parameter cutOff = 3  # the pipeline dataset = iris %>%    track() %>%   status() %>%   group_by(Species) %>%   status(     short = p_count_if(Sepal.Width<cutOff),      long= p_count_if(Sepal.Width>=cutOff),      .messages=c(\"consisting of {short} short sepal <{cutOff}\",\"and {long} long sepal >={cutOff}\")   )  %>%   exclude_all(     Petal.Width<0.3 ~ \"excluding {.excluded} with narrow petals\",     Petal.Width == max(Petal.Width) ~ \"and {.excluded} outlier\"   ) %>%   comment(\"test message\") %>%   status(.messages = \"{.count} of type {Species}\") %>%   ungroup() %>%   status(.messages = \"{.count} together with cutOff {cutOff}\") dataset %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/add_count.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — add_count.trackr_df","title":"dplyr modifying operations — add_count.trackr_df","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/add_count.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — add_count.trackr_df","text":"","code":"# S3 method for class 'trackr_df' add_count(x, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/add_count.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — add_count.trackr_df","text":"x data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). ... <data-masking> Variables group .   Named arguments passed dplyr::add_count wt <data-masking> Frequency weights. Can NULL variable: NULL (default), counts number rows group. variable, computes sum(wt) group. sort TRUE, show largest groups top. name name new column output. omitted, default n. already column called n, use nn. column called n nn, 'll use nnn, , adding ns gets new name. .drop Handling factor levels appear data, passed group_by(). count(): FALSE include counts empty groups (.e. levels factors exist data). add_count(): deprecated since actually affect output. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/add_count.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — add_count.trackr_df","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/add_count.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — add_count.trackr_df","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:dtrackr’: #>  #>     add_tally, bind_cols, bind_rows #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # add_count # adding in a count or tally column as a new column iris %>%   track() %>%   add_count(Species, name=\"new_count_total\",             .messages=\"{.new_cols}\",             # .messages=\"{.cols}\",             .headline=\"New columns from add_count:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"New columns from add_count:\", \"new_count_total\"  # add_tally iris %>%   track() %>%   group_by(Species) %>%   dtrackr::add_tally(wt=Petal.Length, name=\"new_tally_total\",             .messages=\"{.new_cols}\",             .headline=\"New columns from add_tally:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"New columns from add_tally:\", \"new_tally_total\" #> ├ [Species:versicolor]: \"New columns from add_tally:\", \"new_tally_total\" #> └ [Species:virginica]: \"New columns from add_tally:\", \"new_tally_total\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/add_tally.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — add_tally","title":"dplyr modifying operations — add_tally","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/add_tally.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — add_tally","text":"","code":"add_tally(x, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/add_tally.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — add_tally","text":"x data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). ... <data-masking> Variables group .   Named arguments passed dplyr::add_tally wt <data-masking> Frequency weights. Can NULL variable: NULL (default), counts number rows group. variable, computes sum(wt) group. sort TRUE, show largest groups top. name name new column output. omitted, default n. already column called n, use nn. column called n nn, 'll use nnn, , adding ns gets new name. .drop Handling factor levels appear data, passed group_by(). count(): FALSE include counts empty groups (.e. levels factors exist data). add_count(): deprecated since actually affect output. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/add_tally.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — add_tally","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/add_tally.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — add_tally","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # add_count # adding in a count or tally column as a new column iris %>%   track() %>%   add_count(Species, name=\"new_count_total\",             .messages=\"{.new_cols}\",             # .messages=\"{.cols}\",             .headline=\"New columns from add_count:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"New columns from add_count:\", \"new_count_total\"  # add_tally iris %>%   track() %>%   group_by(Species) %>%   dtrackr::add_tally(wt=Petal.Length, name=\"new_tally_total\",             .messages=\"{.new_cols}\",             .headline=\"New columns from add_tally:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"New columns from add_tally:\", \"new_tally_total\" #> ├ [Species:versicolor]: \"New columns from add_tally:\", \"new_tally_total\" #> └ [Species:virginica]: \"New columns from add_tally:\", \"new_tally_total\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/anti_join.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Anti join — anti_join.trackr_df","title":"Anti join — anti_join.trackr_df","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::anti_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/anti_join.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Anti join — anti_join.trackr_df","text":"","code":"# S3 method for class 'trackr_df' anti_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\", \"{.count.out} not matched\"),   .headline = \"Semi join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/anti_join.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Anti join — anti_join.trackr_df","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods. .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/anti_join.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Anti join — anti_join.trackr_df","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/anti_join.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Anti join — anti_join.trackr_df","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Anti join join = lhs %>% anti_join(rhs, by=\"name\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() %>% print() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 0\" nrow(join) #> [1] 0 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/arrange.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — arrange.trackr_df","title":"dplyr modifying operations — arrange.trackr_df","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/arrange.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — arrange.trackr_df","text":"","code":"# S3 method for class 'trackr_df' arrange(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/arrange.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — arrange.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. Named arguments passed dplyr::arrange .by_group TRUE, sort first grouping variable. Applies grouped data frames . .locale locale sort character vectors . NULL, default, uses \"C\" locale unless dplyr.legacy_locale global option escape hatch active. See dplyr-locale help page details. single string stringi::stri_locale_list() supplied, used locale sort . example, \"en\" sort American English locale. requires stringi package. \"C\" supplied, character vectors always sorted C locale. require stringi often much faster supplying locale identifier. C locale English locales, \"en\", particularly comes data containing mix upper lower case letters. explained detail locale help page Default locale section. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/arrange.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — arrange.trackr_df","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/arrange.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — arrange.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # arrange # In this case we sort the data descending and show the first value # is the same as the maximum value. iris %>%   track() %>%   arrange(     desc(Petal.Width),     .messages=\"{.count} items, columns: {.cols}\",     .headline=\"Reordered dataframe:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"Reordered dataframe:\", \"150 items, columns: Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, Species\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/bind_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — bind_cols","title":"Set operations — bind_cols","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/bind_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — bind_cols","text":"","code":"bind_cols(   ...,   .messages = \"{.count.out} in combined set\",   .headline = \"Bind columns\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/bind_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — bind_cols","text":"... collection tracked data frames combine   Named arguments passed dplyr::bind_cols .name_repair One \"unique\", \"universal\", \"check_unique\". See vctrs::vec_as_names() meaning options. .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/bind_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — bind_cols","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/bind_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — bind_cols","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/bind_rows.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — bind_rows","title":"Set operations — bind_rows","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/bind_rows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — bind_rows","text":"","code":"bind_rows(..., .messages = \"{.count.out} in union\", .headline = \"Union\")"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/bind_rows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — bind_rows","text":"... collection tracked data frames combine   Named arguments passed dplyr::bind_rows .id name optional identifier column. Provide string create output column identifies input. column use names available, otherwise use positions. .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/bind_rows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — bind_rows","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/bind_rows.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — bind_rows","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/capture_exclusions.html","id":null,"dir":"Reference","previous_headings":"","what":"Start capturing exclusions on a tracked dataframe. — capture_exclusions","title":"Start capturing exclusions on a tracked dataframe. — capture_exclusions","text":"Start capturing exclusions tracked dataframe.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/capture_exclusions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Start capturing exclusions on a tracked dataframe. — capture_exclusions","text":"","code":"capture_exclusions(.data, .capture = TRUE)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/capture_exclusions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Start capturing exclusions on a tracked dataframe. — capture_exclusions","text":".data tracked dataframe .capture capture exclusions (things removed data set). useful debugging data issues comes significant cost. Defaults value getOption(\"dtrackr.exclusions\") FALSE.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/capture_exclusions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Start capturing exclusions on a tracked dataframe. — capture_exclusions","text":".data dataframe exclusions flag set (cleared .capture=FALSE).","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/capture_exclusions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Start capturing exclusions on a tracked dataframe. — capture_exclusions","text":"","code":"library(dplyr) library(dtrackr) tmp = iris %>% track() %>% capture_exclusions() tmp %>% filter(Species!=\"versicolor\") %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: 50 #> last entry / entries: #> └ \"150 items\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/comment.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a generic comment to the dtrackr history graph — comment","title":"Add a generic comment to the dtrackr history graph — comment","text":"comment can kind note added every current grouping defined .message field. can made context specific including variables {.count} {.total} .message refer grouped ungrouped counts current stage pipeline respectively. can also pull global variable.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/comment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a generic comment to the dtrackr history graph — comment","text":"","code":"comment(   .data,   .messages = .defaultMessage(),   .headline = .defaultHeadline(),   .type = \"info\",   .asOffshoot = (.type == \"exclusion\"),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/comment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a generic comment to the dtrackr history graph — comment","text":".data dataframe may grouped .messages character vector glue specifications. glue specification can refer grouping variables .data, variables defined calling environment, {.total} rows, {.count} variable count group {.strata} description group .headline glue specification can refer grouping variables .data, variables defined calling environment, {.total} variable (nrow(.data)) {.strata} description grouping .type one \"info\",\"...,\"exclusion\": used define formatting .asOffshoot want comment offshoot main flow (default = FALSE). .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/comment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a generic comment to the dtrackr history graph — comment","text":".data dataframe history graph updated comment","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/comment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a generic comment to the dtrackr history graph — comment","text":"","code":"library(dplyr) library(dtrackr) iris %>% track() %>% comment(\"hello {.total} rows\") %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"hello 150 rows\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/count_subgroup.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a subgroup count to the dtrackr history graph — count_subgroup","title":"Add a subgroup count to the dtrackr history graph — count_subgroup","text":"frequent use case detailed description subgroup count within flowchart. works best factor subgroup columns data converted factor automatically. count items subgroup added new stage flowchart.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/count_subgroup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a subgroup count to the dtrackr history graph — count_subgroup","text":"","code":"count_subgroup(   .data,   .subgroup,   ...,   .messages = .defaultCountSubgroup(),   .headline = .defaultHeadline(),   .type = \"info\",   .asOffshoot = FALSE,   .tag = NULL,   .maxsubgroups = .defaultMaxSupportedGroupings() )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/count_subgroup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a subgroup count to the dtrackr history graph — count_subgroup","text":".data dataframe may grouped .subgroup column small number levels (e.g. factor) ... passed base::factor(subgroup values, ...) allow reordering levels etc. .messages character vector glue specifications. glue specification can refer anything calling environment, {.subgroup} subgroup column name {.name} subgroup column value, {.count} subgroup column count, {.subtotal} current stratification grouping count {.total} whole dataset count .headline glue specification can refer grouping variables .data, {.subtotal} current grouping count, variables defined calling environment .type one \"info\",\"exclusion\": used define formatting .asOffshoot want comment offshoot main flow (default = FALSE). .tag want use summary data step future give name .tag. .maxsubgroups maximum number discrete values allowed .subgroup configurable options(\"dtrackr.max_supported_groupings\"=XX). default 16. Large values produce unwieldy flow charts.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/count_subgroup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a subgroup count to the dtrackr history graph — count_subgroup","text":".data dataframe history graph updated subgroup count new stage","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/count_subgroup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a subgroup count to the dtrackr history graph — count_subgroup","text":"","code":"library(dplyr) library(dtrackr) survival::cgd %>% track() %>% group_by(treat) %>%   count_subgroup(center) %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [treat:placebo]: \"treat:placebo\", \"Harvard Medical Sch: 3 items\", \"Scripps Institute: 22 items\", \"Copenhagen: 4 items\", \"NIH: 20 items\", \"L.A. Children's Hosp: 8 items\", \"Mott Children's Hosp: 13 items\", \"Univ. of Utah: 2 items\", \"Univ. of Washington: 2 items\", \"Univ. of Minnesota: 7 items\", \"Univ. of Zurich: 13 items\", \"Texas Children's Hosp: 7 items\", \"Amsterdam: 16 items\", \"Mt. Sinai Medical Ctr: 3 items\" #> └ [treat:rIFN-g]: \"treat:rIFN-g\", \"Harvard Medical Sch: 1 items\", \"Scripps Institute: 14 items\", \"Copenhagen: 1 items\", \"NIH: 21 items\", \"L.A. Children's Hosp: 5 items\", \"Mott Children's Hosp: 7 items\", \"Univ. of Utah: 3 items\", \"Univ. of Washington: 2 items\", \"Univ. of Minnesota: 3 items\", \"Univ. of Zurich: 8 items\", \"Texas Children's Hosp: 4 items\", \"Amsterdam: 12 items\", \"Mt. Sinai Medical Ctr: 2 items\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/distinct.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Distinct values of data — distinct.trackr_df","title":"Distinct values of data — distinct.trackr_df","text":"Distinct acts way dplyr::distinct. Prior operation size group calculated {.count.} operation output size {.count.} group {.strata} also available (grouped) reporting. See dplyr::distinct().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/distinct.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distinct values of data — distinct.trackr_df","text":"","code":"# S3 method for class 'trackr_df' distinct(   .data,   ...,   .messages = \"removing {.count.in-.count.out} duplicates\",   .headline = .defaultHeadline(),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/distinct.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distinct values of data — distinct.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Optional variables use determining uniqueness. multiple rows given combination inputs, first row preserved. omitted, use variables data frame.   Named arguments passed dplyr::distinct .keep_all TRUE, keep variables .data. combination ... distinct, keeps first row values. .messages set glue specs. glue code can use global variable, {.strata},{.count.},{.count.} .headline headline glue spec. glue code can use global variable, {.strata},{.count.},{.count.} .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/distinct.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distinct values of data — distinct.trackr_df","text":".data dataframe distinct values history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/distinct.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distinct values of data — distinct.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  tmp = bind_rows(iris %>% track(), iris %>% track() %>% filter(Petal.Length > 5)) tmp %>% group_by(Species) %>% distinct() %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Species:setosa\", \"removing 0 duplicates\" #> ├ [Species:versicolor]: \"Species:versicolor\", \"removing 1 duplicates\" #> └ [Species:virginica]: \"Species:virginica\", \"removing 42 duplicates\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/dot2svg.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Graphviz dot content to a SVG — dot2svg","title":"Convert Graphviz dot content to a SVG — dot2svg","text":"Convert graphviz dot digraph string SVG string","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/dot2svg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Graphviz dot content to a SVG — dot2svg","text":"","code":"dot2svg(dot)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/dot2svg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Graphviz dot content to a SVG — dot2svg","text":"dot graphviz dot string","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/dot2svg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Graphviz dot content to a SVG — dot2svg","text":"SVG string","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/dot2svg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Graphviz dot content to a SVG — dot2svg","text":"","code":"dot2svg(\"digraph { A->B }\") #> [1] \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\"\\n \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\\n<!-- Generated by graphviz version 2.40.1 (20161225.0304)\\n -->\\n<!-- Title: %0 Pages: 1 -->\\n<svg width=\\\"62pt\\\" height=\\\"116pt\\\"\\n viewBox=\\\"0.00 0.00 62.00 116.00\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">\\n<g id=\\\"graph0\\\" class=\\\"graph\\\" transform=\\\"scale(1 1) rotate(0) translate(4 112)\\\">\\n<title>%0<\/title>\\n<polygon fill=\\\"#ffffff\\\" stroke=\\\"transparent\\\" points=\\\"-4,4 -4,-112 58,-112 58,4 -4,4\\\"/>\\n<!-- A -->\\n<g id=\\\"node1\\\" class=\\\"node\\\">\\n<title>A<\/title>\\n<ellipse fill=\\\"none\\\" stroke=\\\"#000000\\\" cx=\\\"27\\\" cy=\\\"-90\\\" rx=\\\"27\\\" ry=\\\"18\\\"/>\\n<text text-anchor=\\\"middle\\\" x=\\\"27\\\" y=\\\"-85.8\\\" font-family=\\\"Times,serif\\\" font-size=\\\"14.00\\\" fill=\\\"#000000\\\">A<\/text>\\n<\/g>\\n<!-- B -->\\n<g id=\\\"node2\\\" class=\\\"node\\\">\\n<title>B<\/title>\\n<ellipse fill=\\\"none\\\" stroke=\\\"#000000\\\" cx=\\\"27\\\" cy=\\\"-18\\\" rx=\\\"27\\\" ry=\\\"18\\\"/>\\n<text text-anchor=\\\"middle\\\" x=\\\"27\\\" y=\\\"-13.8\\\" font-family=\\\"Times,serif\\\" font-size=\\\"14.00\\\" fill=\\\"#000000\\\">B<\/text>\\n<\/g>\\n<!-- A&#45;&gt;B -->\\n<g id=\\\"edge1\\\" class=\\\"edge\\\">\\n<title>A&#45;&gt;B<\/title>\\n<path fill=\\\"none\\\" stroke=\\\"#000000\\\" d=\\\"M27,-71.8314C27,-64.131 27,-54.9743 27,-46.4166\\\"/>\\n<polygon fill=\\\"#000000\\\" stroke=\\\"#000000\\\" points=\\\"30.5001,-46.4132 27,-36.4133 23.5001,-46.4133 30.5001,-46.4132\\\"/>\\n<\/g>\\n<\/g>\\n<\/svg>\\n\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/dtrackr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"dtrackr: Track your Data Pipelines — dtrackr-package","title":"dtrackr: Track your Data Pipelines — dtrackr-package","text":"Track document 'dplyr' data pipelines. filter, mutate, join way data set, 'dtrackr' seamlessly keeps track data flow makes publication ready documentation data pipeline simple.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/dtrackr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"dtrackr: Track your Data Pipelines — dtrackr-package","text":"Maintainer: Robert Challen rob.challen@bristol.ac.uk (ORCID)","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/exclude_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Exclude all items matching one or more criteria — exclude_all","title":"Exclude all items matching one or more criteria — exclude_all","text":"Apply set filters summarise actions filter dtrackr history graph. ... filter specification, parameters MUST NAMED. filters work combinatorial manner, .e. results EXCLUDE rows match criteria. na.rm = TRUE also remove anything evaluated criteria.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/exclude_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exclude all items matching one or more criteria — exclude_all","text":"","code":"exclude_all(   .data,   ...,   .headline = .defaultHeadline(),   na.rm = FALSE,   .type = \"exclusion\",   .asOffshoot = TRUE,   .stage = (if (is.null(.tag)) \"\" else .tag),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/exclude_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exclude all items matching one or more criteria — exclude_all","text":".data dataframe may grouped ... dplyr filter specification set formulae LHS predicates test data set , items match predicates excluded. RHS glue specification, defining message, entered history graph predicate. can refer grouping variables variables environment {.excluded} {.matched} {.missing} (excluded = matched+missing), {.count} {.total} - group overall counts respectively, e.g. \"excluding {.matched} items {.missing} missing values\". .headline glue specification can refer grouping variables .data, variables defined calling environment na.rm (default FALSE) filter evaluated row count row missing either exclude (TRUE) exclude (FALSE) .type default \"exclusion\": used define formatting .asOffshoot want comment offshoot main flow (default = TRUE). .stage name step pathway .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/exclude_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exclude all items matching one or more criteria — exclude_all","text":"filtered .data dataframe history graph updated summary excluded items new offshoot stage","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/exclude_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exclude all items matching one or more criteria — exclude_all","text":"","code":"library(dplyr) library(dtrackr)  iris %>% track() %>% capture_exclusions() %>% exclude_all(       Petal.Length > 5 ~ \"{.excluded} long ones\",       Petal.Length < 2 ~ \"{.excluded} short ones\" ) %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: 92 #> last entry / entries: #> └ \"150 items\"   # simultaneous evaluation of criteria: data.frame(a = 1:10) %>%   track() %>%   exclude_all(     # These two criteria identify the same value and one item is excluded     a > 9 ~ \"{.excluded} value > 9\",     a == max(a) ~ \"{.excluded} max value\",   ) %>%   status() %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"9 items\"  # the behaviour is equivalent to the inverse of dplyr's filter function: data.frame(a=1:10) %>%   dplyr::filter(a <= 9, a != max(a)) %>%   nrow() #> [1] 9  # step-wise evaluation of criteria results in a different output data.frame(a = 1:10) %>%   track() %>%   # Performing the same exclusion sequentially results in 2 items   # being excluded as the criteria no longer identify the same   # item.   exclude_all(a > 9 ~ \"{.excluded} value > 9\") %>%   exclude_all(a == max(a) ~ \"{.excluded} max value\") %>%   status() %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"8 items\"  # the behaviour is equivalent to the inverse of dplyr's filter function: data.frame(a=1:10) %>%   dplyr::filter(a <= 9) %>%   dplyr::filter(a != max(a)) %>%   nrow() #> [1] 8"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/excluded.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the dtrackr excluded data record — excluded","title":"Get the dtrackr excluded data record — excluded","text":"Get dtrackr excluded data record","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/excluded.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the dtrackr excluded data record — excluded","text":"","code":"excluded(.data, simplify = TRUE)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/excluded.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the dtrackr excluded data record — excluded","text":".data dataframe may grouped simplify return single summary dataframe exclusions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/excluded.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the dtrackr excluded data record — excluded","text":"new dataframe excluded data point workflow. dataframe default flattened, .simplify=FALSE nested structure containing records excluded part pipeline.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/excluded.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the dtrackr excluded data record — excluded","text":"","code":"library(dplyr) library(dtrackr) tmp = iris %>% track() %>% capture_exclusions() tmp %>% exclude_all(    Petal.Length > 5.8 ~ \"{.excluded} long ones\",    Petal.Length < 1.3 ~ \"{.excluded} short ones\",    .stage = \"petal length exclusion\" ) %>% excluded() #> # A tibble: 17 × 9 #>    .stage     .strata .message Sepal.Length Sepal.Width Petal.Length Petal.Width #>    <chr>      <chr>   <glue>   <chr>        <chr>       <chr>        <chr>       #>  1 petal len… \"\"      13 long… 6.3          3.3         6            2.5         #>  2 petal len… \"\"      13 long… 7.1          3           5.9          2.1         #>  3 petal len… \"\"      13 long… 7.6          3           6.6          2.1         #>  4 petal len… \"\"      13 long… 7.3          2.9         6.3          1.8         #>  5 petal len… \"\"      13 long… 7.2          3.6         6.1          2.5         #>  6 petal len… \"\"      13 long… 7.7          3.8         6.7          2.2         #>  7 petal len… \"\"      13 long… 7.7          2.6         6.9          2.3         #>  8 petal len… \"\"      13 long… 7.7          2.8         6.7          2           #>  9 petal len… \"\"      13 long… 7.2          3.2         6            1.8         #> 10 petal len… \"\"      13 long… 7.4          2.8         6.1          1.9         #> 11 petal len… \"\"      13 long… 7.9          3.8         6.4          2           #> 12 petal len… \"\"      13 long… 7.7          3           6.1          2.3         #> 13 petal len… \"\"      13 long… 6.8          3.2         5.9          2.3         #> 14 petal len… \"\"      4 short… 4.3          3           1.1          0.1         #> 15 petal len… \"\"      4 short… 5.8          4           1.2          0.2         #> 16 petal len… \"\"      4 short… 4.6          3.6         1            0.2         #> 17 petal len… \"\"      4 short… 5            3.2         1.2          0.2         #> # ℹ 2 more variables: Species <chr>, .filter <chr>"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/filter.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtering data — filter.trackr_df","title":"Filtering data — filter.trackr_df","text":"Filter acts way dplyr predicates evaluate TRUE act select items include, items predicate evaluated excluded. tracking prior filter operation size group calculated {.count.} operation output size group {.count.}. grouping {.strata} also available (grouped) reporting. See dplyr::filter().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/filter.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtering data — filter.trackr_df","text":"","code":"# S3 method for class 'trackr_df' filter(   .data,   ...,   .messages = \"excluded {.excluded} items\",   .headline = .defaultHeadline(),   .type = \"exclusion\",   .asOffshoot = (.type == \"exclusion\"),   .stage = (if (is.null(.tag)) \"\" else .tag),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/filter.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtering data — filter.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Expressions return logical value, defined terms variables .data. multiple expressions included, combined & operator. rows conditions evaluate TRUE kept.   Named arguments passed dplyr::filter . <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . .messages set glue specs. glue code can use global variable, {.strata},{.count.},{.count.} .headline headline glue spec. glue code can use global variable, {.strata},{.count.},{.count.} .type format type action typically exclusion .asOffshoot type exclusion, .asOffshoot places information box outside main flow, exclusion. .stage name step pathway .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/filter.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtering data — filter.trackr_df","text":"filtered .data dataframe history graph updated","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/filter.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtering data — filter.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% track() %>% group_by(Species) tmp %>% filter(Petal.Length > 5) %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"stratify by Species\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/flowchart.html","id":null,"dir":"Reference","previous_headings":"","what":"Flowchart output — flowchart","title":"Flowchart output — flowchart","text":"Generate flowchart history dataframe(s), tracked data pipeline stages flowchart. Multiple dataframes can plotted together case attempt made determine parts common.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/flowchart.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flowchart output — flowchart","text":"","code":"flowchart(   .data,   filename = NULL,   size = std_size$full,   maxWidth = size$width,   maxHeight = size$height,   formats = c(\"dot\", \"png\", \"pdf\", \"svg\"),   defaultToHTML = TRUE,   landscape = size$rot != 0,   ... )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/flowchart.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flowchart output — flowchart","text":".data tracked dataframe(s) either single dataframe list dataframes. filename file name formatted flowcharts saved. extension specified output formats determined formats parameter. size named list 3 elements, length width inches rotation. predefined set standard sizes available std_size object. maxWidth width (paper) inches size defined maxHeight height (paper) inches size defined formats pdf,dot,svg,png,ps defaultToHTML correct output format easy determine context, default providing HTML (TRUE) embedding PNG (FALSE) landscape rotate output 270 degrees landscape format. maxWidth maxHeight still apply refer paper width fit flowchart rotation. (might need flip width height) ... parameters passed onto either p_get_as_dot(), notable ones fill (background colour e.g. lightgrey), fontsize (points), colour (font colour)","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/flowchart.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flowchart output — flowchart","text":"nature flowchart output depends context function called. form browse-able html output called interactive session PNG/PDF link knitr knitting latex word type outputs, file name specified output also saved given location.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/flowchart.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flowchart output — flowchart","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% track() %>% comment(.tag = \"step1\") %>% filter(Species!=\"versicolor\") tmp %>% group_by(Species) %>% comment(.tag=\"step2\") %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/full_join.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Full join — full_join.trackr_df","title":"Full join — full_join.trackr_df","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::full_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/full_join.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Full join — full_join.trackr_df","text":"","code":"# S3 method for class 'trackr_df' full_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\",     \"{.count.out} in linked set\"),   .headline = \"Full join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/full_join.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Full join — full_join.trackr_df","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::full_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . suffix non-joined duplicate variables x y, suffixes added output disambiguate . character vector length 2. keep join keys x y preserved output? NULL, default, joins equality retain keys x, joins inequality retain keys inputs. TRUE, keys inputs retained. FALSE, keys x retained. right full joins, data key columns corresponding rows exist y merged key columns x. used joining inequality conditions. na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). multiple Handling rows x multiple matches y. row x: \"\", default, returns every match detected y. behavior SQL. \"\" returns one match detected y, guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected y. \"last\" returns last match detected y. unmatched unmatched keys result dropped rows handled? \"drop\" drops unmatched keys result. \"error\" throws error unmatched keys detected. unmatched intended protect accidentally dropping rows join. checks unmatched keys input potentially drop rows. left joins, checks y. right joins, checks x. inner joins, checks x y. case, unmatched also allowed character vector length 2 specify behavior x y independently. relationship Handling expected relationship keys x y. expectations chosen list invalidated, error thrown. NULL, default, expect relationship x y. However, equality joins check many--many relationship (typically unexpected) warn one occurs, encouraging either take closer look inputs make relationship explicit specifying \"many--many\". See Many--many relationships section details. \"one--one\" expects: row x matches 1 row y. row y matches 1 row x. \"one--many\" expects: row y matches 1 row x. \"many--one\" expects: row x matches 1 row y. \"many--many\" perform relationship checks, provided allow explicit relationship know exists. relationship handle cases zero matches. , see unmatched. .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/full_join.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Full join — full_join.trackr_df","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/full_join.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Full join — full_join.trackr_df","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Full join join = lhs %>% full_join(rhs, by=\"name\", multiple = \"all\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 173\" nrow(join) #> [1] 173 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/group_by.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Stratifying your analysis — group_by.trackr_df","title":"Stratifying your analysis — group_by.trackr_df","text":"Grouping data set acts normal way. tracking dataframe sometimes group_by() operation create lot groups. happens example group_by(), summarise() step aggregating data fine scale, e.g. day time-series. generally terrible idea tracking dataframe resulting flowchart many many branches illegible. dtrackr detect issue pause tracking dataframe warning. user resume() tracking large number groups resolved e.g. using dplyr::ungroup(). limit configurable options(\"dtrackr.max_supported_groupings\"=XX). default 16. See dplyr::group_by().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/group_by.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stratifying your analysis — group_by.trackr_df","text":"","code":"# S3 method for class 'trackr_df' group_by(   .data,   ...,   .messages = \"stratify by {.cols}\",   .headline = NULL,   .tag = NULL,   .maxgroups = .defaultMaxSupportedGroupings() )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/group_by.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stratifying your analysis — group_by.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... group_by(), variables computations group . Computations always done ungrouped data frame. perform computations grouped data, need use separate mutate() step group_by(). Computations allowed nest_by(). ungroup(), variables remove grouping.   Named arguments passed dplyr::group_by .add FALSE, default, group_by() override existing groups. add existing groups, use .add = TRUE. argument previously called add, prevented creating new grouping variable called add, conflicts naming conventions. .drop Drop groups formed factor levels appear data? default TRUE except .data previously grouped .drop = FALSE. See group_by_drop_default() details. x tbl() .messages set glue specs. glue code can use global variable, {.cols} columns grouped . .headline headline glue spec. glue code can use global variable, {.cols}. .tag want summary data step future give name .tag. .maxgroups maximum number subgroups allowed tracking paused.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/group_by.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stratifying your analysis — group_by.trackr_df","text":".data grouped.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/group_by.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stratifying your analysis — group_by.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% track() %>% group_by(Species, .messages=\"stratify by {.cols}\") tmp %>% comment(\"{.strata}\") %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Species:setosa\", \"Species:setosa\" #> ├ [Species:versicolor]: \"Species:versicolor\", \"Species:versicolor\" #> └ [Species:virginica]: \"Species:virginica\", \"Species:virginica\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/group_modify.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Group-wise modification of data and complex operations — group_modify.trackr_df","title":"Group-wise modification of data and complex operations — group_modify.trackr_df","text":"Group modifying data set acts normal way. internal mechanics modify function opaque history. means can used wrap unsupported operation without losing history (e.g. df %>% track() %>% group_modify(function(d,...) { d %>% unsupported_operation() }) ) Prior operation size group calculated {.count.} operation output size {.count.} group {.strata} also available (grouped) reporting See dplyr::group_modify().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/group_modify.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group-wise modification of data and complex operations — group_modify.trackr_df","text":"","code":"# S3 method for class 'trackr_df' group_modify(   .data,   ...,   .messages = NULL,   .headline = .defaultHeadline(),   .type = \"modify\",   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/group_modify.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group-wise modification of data and complex operations — group_modify.trackr_df","text":".data grouped tibble ... Additional arguments passed .f   Named arguments passed dplyr::group_modify .f function formula apply group. function, used . least 2 formal arguments. formula, e.g. ~ head(.x), converted function. formula, can use . .x refer subset rows .tbl given group .y refer key, one row tibble one column per grouping variable identifies group .keep grouping variables kept .x .messages set glue specs. glue code can use global variable, {.strata},{.count.},{.count.} .headline headline glue spec. glue code can use global variable, {.strata},{.count.},{.count.} .type default \"modify\": used define formatting .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/group_modify.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group-wise modification of data and complex operations — group_modify.trackr_df","text":"transformed .data dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/group_modify.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group-wise modification of data and complex operations — group_modify.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% track() %>% group_by(Species) tmp %>% group_modify(       function(d,g,...) { return(tibble::tibble(x=runif(10))) },       .messages=\"{.count.in} in, {.count.out} out\" ) %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Species:setosa\", \"50 in, 10 out\" #> ├ [Species:versicolor]: \"Species:versicolor\", \"50 in, 10 out\" #> └ [Species:virginica]: \"Species:virginica\", \"50 in, 10 out\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/history.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the dtrackr history graph — history","title":"Get the dtrackr history graph — history","text":"provides raw history graph really intended mainstream use. internal structure graph explained . print plot S3 methods exist dtrackr history graph.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/history.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the dtrackr history graph — history","text":"","code":"history(.data)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/history.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the dtrackr history graph — history","text":".data dataframe may grouped","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/history.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the dtrackr history graph — history","text":"history graph. list, class trackr_graph, containing following named items: excluded - data items excluded thus far nested dataframe tags - dataframe tag-value pairs containing summary data named points data flow (see tagged()) nodes - dataframe nodes flow chart edges - edge list (dataframe) relationships nodes flow chart head - current recent nodes added graph dataframe. format data may grow time fields unlikely changed.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/history.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the dtrackr history graph — history","text":"","code":"library(dplyr) library(dtrackr) graph = iris %>% track() %>% comment(\"A comment\") %>% history() print(graph) #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"A comment\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/include_any.html","id":null,"dir":"Reference","previous_headings":"","what":"Include any items matching a criteria — include_any","title":"Include any items matching a criteria — include_any","text":"Apply set inclusion criteria record actions filter dtrackr history graph. ... filter specification, parameters MUST NAMED. function opposite exclude_all() filtering criteria work identify rows include .e. results include anything match criteria. na.rm=TRUE also keep anything evaluated criteria.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/include_any.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Include any items matching a criteria — include_any","text":"","code":"include_any(   .data,   ...,   .headline = .defaultHeadline(),   na.rm = TRUE,   .type = \"inclusion\",   .asOffshoot = FALSE,   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/include_any.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Include any items matching a criteria — include_any","text":".data dataframe may grouped ... dplyr filter specification set formulae LHS predicates test data set , items match least one predicates included. RHS glue specification, defining message, entered history graph predicate matched. can refer grouping variables, variables environment {.included} {.matched} {.missing} (included = matched+missing), {.count} {.total} - group overall counts respectively, e.g. \"excluding {.matched} items {.missing} missing values\". .headline glue specification can refer grouping variables .data, variables defined calling environment na.rm (default TRUE) filter evaluated row count row missing either exclude (TRUE) exclude (FALSE) .type default \"inclusion\": used define formatting .asOffshoot want comment offshoot main flow (default = FALSE). .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/include_any.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Include any items matching a criteria — include_any","text":"filtered .data dataframe history graph updated summary included items new stage","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/include_any.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Include any items matching a criteria — include_any","text":"","code":"library(dplyr) library(dtrackr)  iris %>% track() %>% group_by(Species) %>% include_any(       Petal.Length > 5 ~ \"{.included} long ones\",       Petal.Length < 2 ~ \"{.included} short ones\" ) %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Species:setosa\", \"inclusions:\", \"0 long ones\", \"50 short ones\" #> ├ [Species:versicolor]: \"Species:versicolor\", \"inclusions:\", \"1 long ones\", \"0 short ones\" #> └ [Species:virginica]: \"Species:virginica\", \"inclusions:\", \"41 long ones\", \"0 short ones\"  # simultaneous evaluation of criteria: data.frame(a = 1:10) %>%   track() %>%   include_any(     # These two criteria identify the same value and one item is excluded     a > 1 ~ \"{.included} value > 1\",     a != min(a) ~ \"{.included} everything but the smallest value\",   ) %>%   status() %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"9 items\"  # the behaviour is equivalent to dplyr's filter function: data.frame(a=1:10) %>%   dplyr::filter(a > 1, a != min(a)) %>%   nrow() #> [1] 9  # step-wise evaluation of criteria results in a different output data.frame(a = 1:10) %>%   track() %>%   # Performing the same exclusion sequentially results in 2 items   # being excluded as the criteria no longer identify the same   # item.   include_any(a > 1 ~ \"{.included} value > 1\") %>%   include_any(a != min(a) ~ \"{.included} everything but the smallest value\") %>%   status() %>%   history() #> dtrackr history: #> number of flowchart steps: 4 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"8 items\"  # the behaviour is equivalent to dplyr's filter function: data.frame(a=1:10) %>%   dplyr::filter(a > 1) %>%   dplyr::filter(a != min(a)) %>%   nrow() #> [1] 8"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/inner_join.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Inner joins — inner_join.trackr_df","title":"Inner joins — inner_join.trackr_df","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::inner_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/inner_join.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inner joins — inner_join.trackr_df","text":"","code":"# S3 method for class 'trackr_df' inner_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\",     \"{.count.out} in linked set\"),   .headline = \"Inner join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/inner_join.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inner joins — inner_join.trackr_df","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::inner_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . suffix non-joined duplicate variables x y, suffixes added output disambiguate . character vector length 2. keep join keys x y preserved output? NULL, default, joins equality retain keys x, joins inequality retain keys inputs. TRUE, keys inputs retained. FALSE, keys x retained. right full joins, data key columns corresponding rows exist y merged key columns x. used joining inequality conditions. na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). multiple Handling rows x multiple matches y. row x: \"\", default, returns every match detected y. behavior SQL. \"\" returns one match detected y, guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected y. \"last\" returns last match detected y. unmatched unmatched keys result dropped rows handled? \"drop\" drops unmatched keys result. \"error\" throws error unmatched keys detected. unmatched intended protect accidentally dropping rows join. checks unmatched keys input potentially drop rows. left joins, checks y. right joins, checks x. inner joins, checks x y. case, unmatched also allowed character vector length 2 specify behavior x y independently. relationship Handling expected relationship keys x y. expectations chosen list invalidated, error thrown. NULL, default, expect relationship x y. However, equality joins check many--many relationship (typically unexpected) warn one occurs, encouraging either take closer look inputs make relationship explicit specifying \"many--many\". See Many--many relationships section details. \"one--one\" expects: row x matches 1 row y. row y matches 1 row x. \"one--many\" expects: row y matches 1 row x. \"many--one\" expects: row x matches 1 row y. \"many--many\" perform relationship checks, provided allow explicit relationship know exists. relationship handle cases zero matches. , see unmatched. .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/inner_join.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inner joins — inner_join.trackr_df","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/inner_join.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inner joins — inner_join.trackr_df","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Inner join join = lhs %>% inner_join(rhs, by=\"name\", multiple = \"all\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() %>% print() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 173\" nrow(join) #> [1] 173 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/intersect.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — intersect.trackr_df","title":"Set operations — intersect.trackr_df","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/intersect.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — intersect.trackr_df","text":"","code":"# S3 method for class 'trackr_df' intersect(   x,   y,   ...,   .messages = \"{.count.out} in intersection\",   .headline = \"Intersection\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/intersect.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — intersect.trackr_df","text":"x, y Vectors combine. ... collection tracked data frames combine .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/intersect.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — intersect.trackr_df","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/intersect.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — intersect.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/left_join.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Left join — left_join.trackr_df","title":"Left join — left_join.trackr_df","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::left_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/left_join.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Left join — left_join.trackr_df","text":"","code":"# S3 method for class 'trackr_df' left_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\",     \"{.count.out} in linked set\"),   .headline = \"Left join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/left_join.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Left join — left_join.trackr_df","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::left_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . suffix non-joined duplicate variables x y, suffixes added output disambiguate . character vector length 2. keep join keys x y preserved output? NULL, default, joins equality retain keys x, joins inequality retain keys inputs. TRUE, keys inputs retained. FALSE, keys x retained. right full joins, data key columns corresponding rows exist y merged key columns x. used joining inequality conditions. na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). multiple Handling rows x multiple matches y. row x: \"\", default, returns every match detected y. behavior SQL. \"\" returns one match detected y, guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected y. \"last\" returns last match detected y. unmatched unmatched keys result dropped rows handled? \"drop\" drops unmatched keys result. \"error\" throws error unmatched keys detected. unmatched intended protect accidentally dropping rows join. checks unmatched keys input potentially drop rows. left joins, checks y. right joins, checks x. inner joins, checks x y. case, unmatched also allowed character vector length 2 specify behavior x y independently. relationship Handling expected relationship keys x y. expectations chosen list invalidated, error thrown. NULL, default, expect relationship x y. However, equality joins check many--many relationship (typically unexpected) warn one occurs, encouraging either take closer look inputs make relationship explicit specifying \"many--many\". See Many--many relationships section details. \"one--one\" expects: row x matches 1 row y. row y matches 1 row x. \"one--many\" expects: row y matches 1 row x. \"many--one\" expects: row x matches 1 row y. \"many--many\" perform relationship checks, provided allow explicit relationship know exists. relationship handle cases zero matches. , see unmatched. .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/left_join.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Left join — left_join.trackr_df","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/left_join.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Left join — left_join.trackr_df","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Left join join = lhs %>% left_join(rhs, by=\"name\", multiple = \"all\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 173\" nrow(join) #> [1] 173 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/mutate.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — mutate.trackr_df","title":"dplyr modifying operations — mutate.trackr_df","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/mutate.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — mutate.trackr_df","text":"","code":"# S3 method for class 'trackr_df' mutate(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/mutate.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — mutate.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. Named arguments passed dplyr::mutate . <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .keep Control columns .data retained output. Grouping columns columns created ... always kept. \"\" retains columns .data. default. \"used\" retains columns used ... create new columns. useful checking work, displays inputs outputs side--side. \"unused\" retains columns used ... create new columns. useful generate new columns, longer need columns used generate . \"none\" retain extra columns .data. grouping variables columns created ... kept. .,.<tidy-select> Optionally, control new columns appear (default add right hand side). See relocate() details. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/mutate.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — mutate.trackr_df","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/mutate.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — mutate.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # mutate # In this example we compare the column names of the input and the # output to identify the new columns created by the mutate operation as # the `.new_cols` variable iris %>%   track() %>%   mutate(extra_col = NA_real_,          .messages=\"{.new_cols}\",          .headline=\"Extra columns from mutate:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"Extra columns from mutate:\", \"extra_col\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/nest_join.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Nest join — nest_join.trackr_df","title":"Nest join — nest_join.trackr_df","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::nest_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/nest_join.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nest join — nest_join.trackr_df","text":"","code":"# S3 method for class 'trackr_df' nest_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\", \"{.count.out} matched\"),   .headline = \"Nest join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/nest_join.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nest join — nest_join.trackr_df","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::nest_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . keep new list-column contain join keys? default preserve join keys inequality joins. name name list-column created join. NULL, default, name y used. na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). unmatched unmatched keys result dropped rows handled? \"drop\" drops unmatched keys result. \"error\" throws error unmatched keys detected. unmatched intended protect accidentally dropping rows join. checks unmatched keys input potentially drop rows. left joins, checks y. right joins, checks x. inner joins, checks x y. case, unmatched also allowed character vector length 2 specify behavior x y independently. .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/nest_join.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nest join — nest_join.trackr_df","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/nest_join.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nest join — nest_join.trackr_df","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Nest join join = lhs %>% nest_join(rhs, by=\"name\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() %>% print() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 87\" nrow(join) #> [1] 87 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_add_count.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — p_add_count","title":"dplyr modifying operations — p_add_count","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_add_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — p_add_count","text":"","code":"p_add_count(x, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_add_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — p_add_count","text":"x data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). ... <data-masking> Variables group .   Named arguments passed dplyr::add_count wt <data-masking> Frequency weights. Can NULL variable: NULL (default), counts number rows group. variable, computes sum(wt) group. sort TRUE, show largest groups top. name name new column output. omitted, default n. already column called n, use nn. column called n nn, 'll use nnn, , adding ns gets new name. .drop Handling factor levels appear data, passed group_by(). count(): FALSE include counts empty groups (.e. levels factors exist data). add_count(): deprecated since actually affect output. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_add_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — p_add_count","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_add_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — p_add_count","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # add_count # adding in a count or tally column as a new column iris %>%   track() %>%   add_count(Species, name=\"new_count_total\",             .messages=\"{.new_cols}\",             # .messages=\"{.cols}\",             .headline=\"New columns from add_count:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"New columns from add_count:\", \"new_count_total\"  # add_tally iris %>%   track() %>%   group_by(Species) %>%   dtrackr::add_tally(wt=Petal.Length, name=\"new_tally_total\",             .messages=\"{.new_cols}\",             .headline=\"New columns from add_tally:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"New columns from add_tally:\", \"new_tally_total\" #> ├ [Species:versicolor]: \"New columns from add_tally:\", \"new_tally_total\" #> └ [Species:virginica]: \"New columns from add_tally:\", \"new_tally_total\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_add_tally.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — p_add_tally","title":"dplyr modifying operations — p_add_tally","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_add_tally.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — p_add_tally","text":"","code":"p_add_tally(x, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_add_tally.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — p_add_tally","text":"x data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). ... <data-masking> Variables group . .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_add_tally.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — p_add_tally","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_add_tally.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — p_add_tally","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # add_count # adding in a count or tally column as a new column iris %>%   track() %>%   add_count(Species, name=\"new_count_total\",             .messages=\"{.new_cols}\",             # .messages=\"{.cols}\",             .headline=\"New columns from add_count:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"New columns from add_count:\", \"new_count_total\"  # add_tally iris %>%   track() %>%   group_by(Species) %>%   dtrackr::add_tally(wt=Petal.Length, name=\"new_tally_total\",             .messages=\"{.new_cols}\",             .headline=\"New columns from add_tally:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"New columns from add_tally:\", \"new_tally_total\" #> ├ [Species:versicolor]: \"New columns from add_tally:\", \"new_tally_total\" #> └ [Species:virginica]: \"New columns from add_tally:\", \"new_tally_total\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_anti_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Anti join — p_anti_join","title":"Anti join — p_anti_join","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::anti_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_anti_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Anti join — p_anti_join","text":"","code":"p_anti_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\", \"{.count.out} not matched\"),   .headline = \"Semi join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_anti_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Anti join — p_anti_join","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::anti_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_anti_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Anti join — p_anti_join","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_anti_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Anti join — p_anti_join","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Anti join join = lhs %>% anti_join(rhs, by=\"name\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() %>% print() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 0\" nrow(join) #> [1] 0 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_arrange.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — p_arrange","title":"dplyr modifying operations — p_arrange","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_arrange.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — p_arrange","text":"","code":"p_arrange(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_arrange.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — p_arrange","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. Named arguments passed dplyr::arrange .by_group TRUE, sort first grouping variable. Applies grouped data frames . .locale locale sort character vectors . NULL, default, uses \"C\" locale unless dplyr.legacy_locale global option escape hatch active. See dplyr-locale help page details. single string stringi::stri_locale_list() supplied, used locale sort . example, \"en\" sort American English locale. requires stringi package. \"C\" supplied, character vectors always sorted C locale. require stringi often much faster supplying locale identifier. C locale English locales, \"en\", particularly comes data containing mix upper lower case letters. explained detail locale help page Default locale section. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_arrange.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — p_arrange","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_arrange.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — p_arrange","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # arrange # In this case we sort the data descending and show the first value # is the same as the maximum value. iris %>%   track() %>%   arrange(     desc(Petal.Width),     .messages=\"{.count} items, columns: {.cols}\",     .headline=\"Reordered dataframe:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"Reordered dataframe:\", \"150 items, columns: Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, Species\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_bind_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — p_bind_cols","title":"Set operations — p_bind_cols","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_bind_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — p_bind_cols","text":"","code":"p_bind_cols(   ...,   .messages = \"{.count.out} in combined set\",   .headline = \"Bind columns\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_bind_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — p_bind_cols","text":"... collection tracked data frames combine .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_bind_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — p_bind_cols","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_bind_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — p_bind_cols","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_bind_rows.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — p_bind_rows","title":"Set operations — p_bind_rows","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_bind_rows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — p_bind_rows","text":"","code":"p_bind_rows(..., .messages = \"{.count.out} in union\", .headline = \"Union\")"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_bind_rows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — p_bind_rows","text":"... collection tracked data frames combine .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_bind_rows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — p_bind_rows","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_bind_rows.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — p_bind_rows","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_capture_exclusions.html","id":null,"dir":"Reference","previous_headings":"","what":"Start capturing exclusions on a tracked dataframe. — p_capture_exclusions","title":"Start capturing exclusions on a tracked dataframe. — p_capture_exclusions","text":"Start capturing exclusions tracked dataframe.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_capture_exclusions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Start capturing exclusions on a tracked dataframe. — p_capture_exclusions","text":"","code":"p_capture_exclusions(.data, .capture = TRUE)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_capture_exclusions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Start capturing exclusions on a tracked dataframe. — p_capture_exclusions","text":".data tracked dataframe .capture capture exclusions (things removed data set). useful debugging data issues comes significant cost. Defaults value getOption(\"dtrackr.exclusions\") FALSE.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_capture_exclusions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Start capturing exclusions on a tracked dataframe. — p_capture_exclusions","text":".data dataframe exclusions flag set (cleared .capture=FALSE).","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_capture_exclusions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Start capturing exclusions on a tracked dataframe. — p_capture_exclusions","text":"","code":"library(dplyr) library(dtrackr) tmp = iris %>% track() %>% capture_exclusions() tmp %>% filter(Species!=\"versicolor\") %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: 50 #> last entry / entries: #> └ \"150 items\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_clear.html","id":null,"dir":"Reference","previous_headings":"","what":"Clear the dtrackr history graph — p_clear","title":"Clear the dtrackr history graph — p_clear","text":"unlikely needed directly mostly internal function","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_clear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clear the dtrackr history graph — p_clear","text":"","code":"p_clear(.data)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_clear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clear the dtrackr history graph — p_clear","text":".data dataframe may grouped","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_clear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clear the dtrackr history graph — p_clear","text":".data dataframe history graph removed","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_clear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clear the dtrackr history graph — p_clear","text":"","code":"library(dplyr) library(dtrackr) mtcars %>% track() %>% comment(\"A comment\") %>% p_clear() %>% history() #> dtrackr history: #> number of flowchart steps: 0 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ <empty history> #> TRACKING IS PAUSED (FALSE)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_comment.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a generic comment to the dtrackr history graph — p_comment","title":"Add a generic comment to the dtrackr history graph — p_comment","text":"comment can kind note added every current grouping defined .message field. can made context specific including variables {.count} {.total} .message refer grouped ungrouped counts current stage pipeline respectively. can also pull global variable.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_comment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a generic comment to the dtrackr history graph — p_comment","text":"","code":"p_comment(   .data,   .messages = .defaultMessage(),   .headline = .defaultHeadline(),   .type = \"info\",   .asOffshoot = (.type == \"exclusion\"),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_comment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a generic comment to the dtrackr history graph — p_comment","text":".data dataframe may grouped .messages character vector glue specifications. glue specification can refer grouping variables .data, variables defined calling environment, {.total} rows, {.count} variable count group {.strata} description group .headline glue specification can refer grouping variables .data, variables defined calling environment, {.total} variable (nrow(.data)) {.strata} description grouping .type one \"info\",\"...,\"exclusion\": used define formatting .asOffshoot want comment offshoot main flow (default = FALSE). .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_comment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a generic comment to the dtrackr history graph — p_comment","text":".data dataframe history graph updated comment","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_comment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a generic comment to the dtrackr history graph — p_comment","text":"","code":"library(dplyr) library(dtrackr) iris %>% track() %>% comment(\"hello {.total} rows\") %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"hello 150 rows\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_copy.html","id":null,"dir":"Reference","previous_headings":"","what":"Copy the dtrackr history graph from one dataframe to another — p_copy","title":"Copy the dtrackr history graph from one dataframe to another — p_copy","text":"Copy dtrackr history graph one dataframe another","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_copy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copy the dtrackr history graph from one dataframe to another — p_copy","text":"","code":"p_copy(.data, from)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_copy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Copy the dtrackr history graph from one dataframe to another — p_copy","text":".data dataframe may grouped dataframe copy history graph ","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_copy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Copy the dtrackr history graph from one dataframe to another — p_copy","text":".data dataframe history graph \"\"","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_copy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Copy the dtrackr history graph from one dataframe to another — p_copy","text":"","code":"mtcars %>% p_copy(iris %>% comment(\"A comment\")) %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"A comment\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_count_if.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple count_if dplyr summary function — p_count_if","title":"Simple count_if dplyr summary function — p_count_if","text":"Simple count_if dplyr summary function","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_count_if.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple count_if dplyr summary function — p_count_if","text":"","code":"p_count_if(..., na.rm = TRUE)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_count_if.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple count_if dplyr summary function — p_count_if","text":"... expression evaluated na.rm ignore NA values?","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_count_if.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple count_if dplyr summary function — p_count_if","text":"count number times expression evaluated true, current context","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_count_if.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple count_if dplyr summary function — p_count_if","text":"","code":"library(dplyr) library(dtrackr) tmp = iris %>% dplyr::group_by(Species) tmp %>% dplyr::summarise(long_ones = p_count_if(Petal.Length > 4)) #> # A tibble: 3 × 2 #>   Species    long_ones #>   <fct>          <dbl> #> 1 setosa             0 #> 2 versicolor        34 #> 3 virginica         50"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_count_subgroup.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a subgroup count to the dtrackr history graph — p_count_subgroup","title":"Add a subgroup count to the dtrackr history graph — p_count_subgroup","text":"frequent use case detailed description subgroup count within flowchart. works best factor subgroup columns data converted factor automatically. count items subgroup added new stage flowchart.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_count_subgroup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a subgroup count to the dtrackr history graph — p_count_subgroup","text":"","code":"p_count_subgroup(   .data,   .subgroup,   ...,   .messages = .defaultCountSubgroup(),   .headline = .defaultHeadline(),   .type = \"info\",   .asOffshoot = FALSE,   .tag = NULL,   .maxsubgroups = .defaultMaxSupportedGroupings() )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_count_subgroup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a subgroup count to the dtrackr history graph — p_count_subgroup","text":".data dataframe may grouped .subgroup column small number levels (e.g. factor) ... passed base::factor(subgroup values, ...) allow reordering levels etc. .messages character vector glue specifications. glue specification can refer anything calling environment, {.subgroup} subgroup column name {.name} subgroup column value, {.count} subgroup column count, {.subtotal} current stratification grouping count {.total} whole dataset count .headline glue specification can refer grouping variables .data, {.subtotal} current grouping count, variables defined calling environment .type one \"info\",\"exclusion\": used define formatting .asOffshoot want comment offshoot main flow (default = FALSE). .tag want use summary data step future give name .tag. .maxsubgroups maximum number discrete values allowed .subgroup configurable options(\"dtrackr.max_supported_groupings\"=XX). default 16. Large values produce unwieldy flow charts.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_count_subgroup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a subgroup count to the dtrackr history graph — p_count_subgroup","text":".data dataframe history graph updated subgroup count new stage","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_count_subgroup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a subgroup count to the dtrackr history graph — p_count_subgroup","text":"","code":"library(dplyr) library(dtrackr) survival::cgd %>% track() %>% group_by(treat) %>%   count_subgroup(center) %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [treat:placebo]: \"treat:placebo\", \"Harvard Medical Sch: 3 items\", \"Scripps Institute: 22 items\", \"Copenhagen: 4 items\", \"NIH: 20 items\", \"L.A. Children's Hosp: 8 items\", \"Mott Children's Hosp: 13 items\", \"Univ. of Utah: 2 items\", \"Univ. of Washington: 2 items\", \"Univ. of Minnesota: 7 items\", \"Univ. of Zurich: 13 items\", \"Texas Children's Hosp: 7 items\", \"Amsterdam: 16 items\", \"Mt. Sinai Medical Ctr: 3 items\" #> └ [treat:rIFN-g]: \"treat:rIFN-g\", \"Harvard Medical Sch: 1 items\", \"Scripps Institute: 14 items\", \"Copenhagen: 1 items\", \"NIH: 21 items\", \"L.A. Children's Hosp: 5 items\", \"Mott Children's Hosp: 7 items\", \"Univ. of Utah: 3 items\", \"Univ. of Washington: 2 items\", \"Univ. of Minnesota: 3 items\", \"Univ. of Zurich: 8 items\", \"Texas Children's Hosp: 4 items\", \"Amsterdam: 12 items\", \"Mt. Sinai Medical Ctr: 2 items\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_distinct.html","id":null,"dir":"Reference","previous_headings":"","what":"Distinct values of data — p_distinct","title":"Distinct values of data — p_distinct","text":"Distinct acts way dplyr::distinct. Prior operation size group calculated {.count.} operation output size {.count.} group {.strata} also available (grouped) reporting. See dplyr::distinct().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_distinct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distinct values of data — p_distinct","text":"","code":"p_distinct(   .data,   ...,   .messages = \"removing {.count.in-.count.out} duplicates\",   .headline = .defaultHeadline(),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_distinct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distinct values of data — p_distinct","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Optional variables use determining uniqueness. multiple rows given combination inputs, first row preserved. omitted, use variables data frame.   Named arguments passed dplyr::distinct .keep_all TRUE, keep variables .data. combination ... distinct, keeps first row values. .messages set glue specs. glue code can use global variable, {.strata},{.count.},{.count.} .headline headline glue spec. glue code can use global variable, {.strata},{.count.},{.count.} .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_distinct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distinct values of data — p_distinct","text":".data dataframe distinct values history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_distinct.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distinct values of data — p_distinct","text":"","code":"library(dplyr) library(dtrackr)  tmp = bind_rows(iris %>% track(), iris %>% track() %>% filter(Petal.Length > 5)) tmp %>% group_by(Species) %>% distinct() %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Species:setosa\", \"removing 0 duplicates\" #> ├ [Species:versicolor]: \"Species:versicolor\", \"removing 1 duplicates\" #> └ [Species:virginica]: \"Species:virginica\", \"removing 42 duplicates\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_exclude_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Exclude all items matching one or more criteria — p_exclude_all","title":"Exclude all items matching one or more criteria — p_exclude_all","text":"Apply set filters summarise actions filter dtrackr history graph. ... filter specification, parameters MUST NAMED. filters work combinatorial manner, .e. results EXCLUDE rows match criteria. na.rm = TRUE also remove anything evaluated criteria.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_exclude_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exclude all items matching one or more criteria — p_exclude_all","text":"","code":"p_exclude_all(   .data,   ...,   .headline = .defaultHeadline(),   na.rm = FALSE,   .type = \"exclusion\",   .asOffshoot = TRUE,   .stage = (if (is.null(.tag)) \"\" else .tag),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_exclude_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exclude all items matching one or more criteria — p_exclude_all","text":".data dataframe may grouped ... dplyr filter specification set formulae LHS predicates test data set , items match predicates excluded. RHS glue specification, defining message, entered history graph predicate. can refer grouping variables variables environment {.excluded} {.matched} {.missing} (excluded = matched+missing), {.count} {.total} - group overall counts respectively, e.g. \"excluding {.matched} items {.missing} missing values\". .headline glue specification can refer grouping variables .data, variables defined calling environment na.rm (default FALSE) filter evaluated row count row missing either exclude (TRUE) exclude (FALSE) .type default \"exclusion\": used define formatting .asOffshoot want comment offshoot main flow (default = TRUE). .stage name step pathway .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_exclude_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exclude all items matching one or more criteria — p_exclude_all","text":"filtered .data dataframe history graph updated summary excluded items new offshoot stage","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_exclude_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exclude all items matching one or more criteria — p_exclude_all","text":"","code":"library(dplyr) library(dtrackr)  iris %>% track() %>% capture_exclusions() %>% exclude_all(       Petal.Length > 5 ~ \"{.excluded} long ones\",       Petal.Length < 2 ~ \"{.excluded} short ones\" ) %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: 92 #> last entry / entries: #> └ \"150 items\"   # simultaneous evaluation of criteria: data.frame(a = 1:10) %>%   track() %>%   exclude_all(     # These two criteria identify the same value and one item is excluded     a > 9 ~ \"{.excluded} value > 9\",     a == max(a) ~ \"{.excluded} max value\",   ) %>%   status() %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"9 items\"  # the behaviour is equivalent to the inverse of dplyr's filter function: data.frame(a=1:10) %>%   dplyr::filter(a <= 9, a != max(a)) %>%   nrow() #> [1] 9  # step-wise evaluation of criteria results in a different output data.frame(a = 1:10) %>%   track() %>%   # Performing the same exclusion sequentially results in 2 items   # being excluded as the criteria no longer identify the same   # item.   exclude_all(a > 9 ~ \"{.excluded} value > 9\") %>%   exclude_all(a == max(a) ~ \"{.excluded} max value\") %>%   status() %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"8 items\"  # the behaviour is equivalent to the inverse of dplyr's filter function: data.frame(a=1:10) %>%   dplyr::filter(a <= 9) %>%   dplyr::filter(a != max(a)) %>%   nrow() #> [1] 8"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_excluded.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the dtrackr excluded data record — p_excluded","title":"Get the dtrackr excluded data record — p_excluded","text":"Get dtrackr excluded data record","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_excluded.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the dtrackr excluded data record — p_excluded","text":"","code":"p_excluded(.data, simplify = TRUE)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_excluded.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the dtrackr excluded data record — p_excluded","text":".data dataframe may grouped simplify return single summary dataframe exclusions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_excluded.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the dtrackr excluded data record — p_excluded","text":"new dataframe excluded data point workflow. dataframe default flattened, .simplify=FALSE nested structure containing records excluded part pipeline.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_excluded.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the dtrackr excluded data record — p_excluded","text":"","code":"library(dplyr) library(dtrackr) tmp = iris %>% track() %>% capture_exclusions() tmp %>% exclude_all(    Petal.Length > 5.8 ~ \"{.excluded} long ones\",    Petal.Length < 1.3 ~ \"{.excluded} short ones\",    .stage = \"petal length exclusion\" ) %>% excluded() #> # A tibble: 17 × 9 #>    .stage     .strata .message Sepal.Length Sepal.Width Petal.Length Petal.Width #>    <chr>      <chr>   <glue>   <chr>        <chr>       <chr>        <chr>       #>  1 petal len… \"\"      13 long… 6.3          3.3         6            2.5         #>  2 petal len… \"\"      13 long… 7.1          3           5.9          2.1         #>  3 petal len… \"\"      13 long… 7.6          3           6.6          2.1         #>  4 petal len… \"\"      13 long… 7.3          2.9         6.3          1.8         #>  5 petal len… \"\"      13 long… 7.2          3.6         6.1          2.5         #>  6 petal len… \"\"      13 long… 7.7          3.8         6.7          2.2         #>  7 petal len… \"\"      13 long… 7.7          2.6         6.9          2.3         #>  8 petal len… \"\"      13 long… 7.7          2.8         6.7          2           #>  9 petal len… \"\"      13 long… 7.2          3.2         6            1.8         #> 10 petal len… \"\"      13 long… 7.4          2.8         6.1          1.9         #> 11 petal len… \"\"      13 long… 7.9          3.8         6.4          2           #> 12 petal len… \"\"      13 long… 7.7          3           6.1          2.3         #> 13 petal len… \"\"      13 long… 6.8          3.2         5.9          2.3         #> 14 petal len… \"\"      4 short… 4.3          3           1.1          0.1         #> 15 petal len… \"\"      4 short… 5.8          4           1.2          0.2         #> 16 petal len… \"\"      4 short… 4.6          3.6         1            0.2         #> 17 petal len… \"\"      4 short… 5            3.2         1.2          0.2         #> # ℹ 2 more variables: Species <chr>, .filter <chr>"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtering data — p_filter","title":"Filtering data — p_filter","text":"Filter acts way dplyr predicates evaluate TRUE act select items include, items predicate evaluated excluded. tracking prior filter operation size group calculated {.count.} operation output size group {.count.}. grouping {.strata} also available (grouped) reporting. See dplyr::filter().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtering data — p_filter","text":"","code":"p_filter(   .data,   ...,   .messages = \"excluded {.excluded} items\",   .headline = .defaultHeadline(),   .type = \"exclusion\",   .asOffshoot = (.type == \"exclusion\"),   .stage = (if (is.null(.tag)) \"\" else .tag),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtering data — p_filter","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Expressions return logical value, defined terms variables .data. multiple expressions included, combined & operator. rows conditions evaluate TRUE kept.   Named arguments passed dplyr::filter . <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . .messages set glue specs. glue code can use global variable, {.strata},{.count.},{.count.} .headline headline glue spec. glue code can use global variable, {.strata},{.count.},{.count.} .type format type action typically exclusion .asOffshoot type exclusion, .asOffshoot places information box outside main flow, exclusion. .stage name step pathway .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtering data — p_filter","text":"filtered .data dataframe history graph updated","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtering data — p_filter","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% track() %>% group_by(Species) tmp %>% filter(Petal.Length > 5) %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"stratify by Species\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_flowchart.html","id":null,"dir":"Reference","previous_headings":"","what":"Flowchart output — p_flowchart","title":"Flowchart output — p_flowchart","text":"Generate flowchart history dataframe(s), tracked data pipeline stages flowchart. Multiple dataframes can plotted together case attempt made determine parts common.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_flowchart.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flowchart output — p_flowchart","text":"","code":"p_flowchart(   .data,   filename = NULL,   size = std_size$full,   maxWidth = size$width,   maxHeight = size$height,   formats = c(\"dot\", \"png\", \"pdf\", \"svg\"),   defaultToHTML = TRUE,   landscape = size$rot != 0,   ... )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_flowchart.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flowchart output — p_flowchart","text":".data tracked dataframe(s) either single dataframe list dataframes. filename file name formatted flowcharts saved. extension specified output formats determined formats parameter. size named list 3 elements, length width inches rotation. predefined set standard sizes available std_size object. maxWidth width (paper) inches size defined maxHeight height (paper) inches size defined formats pdf,dot,svg,png,ps defaultToHTML correct output format easy determine context, default providing HTML (TRUE) embedding PNG (FALSE) landscape rotate output 270 degrees landscape format. maxWidth maxHeight still apply refer paper width fit flowchart rotation. (might need flip width height) ... parameters passed onto either p_get_as_dot(), notable ones fill (background colour e.g. lightgrey), fontsize (points), colour (font colour)","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_flowchart.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flowchart output — p_flowchart","text":"nature flowchart output depends context function called. form browse-able html output called interactive session PNG/PDF link knitr knitting latex word type outputs, file name specified output also saved given location.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_flowchart.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flowchart output — p_flowchart","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% track() %>% comment(.tag = \"step1\") %>% filter(Species!=\"versicolor\") tmp %>% group_by(Species) %>% comment(.tag=\"step2\") %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_full_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Full join — p_full_join","title":"Full join — p_full_join","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::full_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_full_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Full join — p_full_join","text":"","code":"p_full_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\",     \"{.count.out} in linked set\"),   .headline = \"Full join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_full_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Full join — p_full_join","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::full_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . suffix non-joined duplicate variables x y, suffixes added output disambiguate . character vector length 2. keep join keys x y preserved output? NULL, default, joins equality retain keys x, joins inequality retain keys inputs. TRUE, keys inputs retained. FALSE, keys x retained. right full joins, data key columns corresponding rows exist y merged key columns x. used joining inequality conditions. na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). multiple Handling rows x multiple matches y. row x: \"\", default, returns every match detected y. behavior SQL. \"\" returns one match detected y, guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected y. \"last\" returns last match detected y. unmatched unmatched keys result dropped rows handled? \"drop\" drops unmatched keys result. \"error\" throws error unmatched keys detected. unmatched intended protect accidentally dropping rows join. checks unmatched keys input potentially drop rows. left joins, checks y. right joins, checks x. inner joins, checks x y. case, unmatched also allowed character vector length 2 specify behavior x y independently. relationship Handling expected relationship keys x y. expectations chosen list invalidated, error thrown. NULL, default, expect relationship x y. However, equality joins check many--many relationship (typically unexpected) warn one occurs, encouraging either take closer look inputs make relationship explicit specifying \"many--many\". See Many--many relationships section details. \"one--one\" expects: row x matches 1 row y. row y matches 1 row x. \"one--many\" expects: row y matches 1 row x. \"many--one\" expects: row x matches 1 row y. \"many--many\" perform relationship checks, provided allow explicit relationship know exists. relationship handle cases zero matches. , see unmatched. .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_full_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Full join — p_full_join","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_full_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Full join — p_full_join","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Full join join = lhs %>% full_join(rhs, by=\"name\", multiple = \"all\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 173\" nrow(join) #> [1] 173 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_get.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the dtrackr history graph — p_get","title":"Get the dtrackr history graph — p_get","text":"provides raw history graph really intended mainstream use. internal structure graph explained . print plot S3 methods exist dtrackr history graph.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the dtrackr history graph — p_get","text":"","code":"p_get(.data)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the dtrackr history graph — p_get","text":".data dataframe may grouped","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the dtrackr history graph — p_get","text":"history graph. list, class trackr_graph, containing following named items: excluded - data items excluded thus far nested dataframe tags - dataframe tag-value pairs containing summary data named points data flow (see tagged()) nodes - dataframe nodes flow chart edges - edge list (dataframe) relationships nodes flow chart head - current recent nodes added graph dataframe. format data may grow time fields unlikely changed.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_get.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the dtrackr history graph — p_get","text":"","code":"library(dplyr) library(dtrackr) graph = iris %>% track() %>% comment(\"A comment\") %>% history() print(graph) #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"A comment\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_get_as_dot.html","id":null,"dir":"Reference","previous_headings":"","what":"DOT output — p_get_as_dot","title":"DOT output — p_get_as_dot","text":"(advance usage) outputs dtrackr history graph DOT string rendering Graphviz","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_get_as_dot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DOT output — p_get_as_dot","text":"","code":"p_get_as_dot(.data, fill = \"lightgrey\", fontsize = \"8\", colour = \"black\", ...)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_get_as_dot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DOT output — p_get_as_dot","text":".data tracked dataframe fill default node fill colour fontsize default font size colour default font colour ... used","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_get_as_dot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"DOT output — p_get_as_dot","text":"representation history graph Graphviz dot format.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_get_as_dot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DOT output — p_get_as_dot","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% track() %>% comment(.tag = \"step1\") %>% filter(Species!=\"versicolor\") dot = tmp %>% group_by(Species) %>% comment(.tag=\"step2\") %>% p_get_as_dot() cat(dot) #> digraph { #>      graph [layout = 'dot', #>         splines='ortho', #>         rankdir = 'TB', #>         outputorder = 'edgesfirst', #>         bgcolor = 'white', #>         ranksep = '0.25', #>         nodesep = '0.2', #>         newrank='true'] #>  #>     node [fontname = 'Helvetica', #>         fontsize = '8', #>         shape='box', #>         fixedsize = 'false', #>         margin = '0.1,0.1', #>         width = '0', #>         height = '0', #>         style = 'filled', #>         color = 'black', #>         fontcolor = 'black', #>         labeljust='l'] #>  #>     edge [fontname = 'Helvetica', #>         fontsize = '8', #>         len = '0.5', #>         color = 'black', #>         arrowsize = '0.5'] #>      #> { rank='same'; #> '5' [label=<<B>Species:setosa<\/B><BR ALIGN='LEFT'/>50 items<BR ALIGN='LEFT'/>>,group='Species:setosa',fillcolor='white']; #> '6' [label=<<B>Species:virginica<\/B><BR ALIGN='LEFT'/>50 items<BR ALIGN='LEFT'/>>,group='Species:virginica',fillcolor='white']; #> } #> { rank='same'; #> '4' [label=<stratify by Species<BR ALIGN='LEFT'/>>,group='',fillcolor='white']; #> } #> { rank='same'; #> '2' [label=<150 items<BR ALIGN='LEFT'/>>,group='',fillcolor='white']; #> '3' [label=<excluded 50 items<BR ALIGN='LEFT'/>>,group='',fillcolor='grey80']; #> } #> { rank='same'; #> '1' [label=<150 items<BR ALIGN='LEFT'/>>,group='',fillcolor='white']; #> } #>  #>  #> '4' -> '6' [tailport='s',weight='100'] #> '4' -> '5' [tailport='s',weight='100'] #> '2' -> '4' [tailport='s',weight='100'] #> '2' -> '3' [tailport='e',weight='1'] #> '1' -> '2' [tailport='s',weight='100'] #> }"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_group_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Stratifying your analysis — p_group_by","title":"Stratifying your analysis — p_group_by","text":"Grouping data set acts normal way. tracking dataframe sometimes group_by() operation create lot groups. happens example group_by(), summarise() step aggregating data fine scale, e.g. day time-series. generally terrible idea tracking dataframe resulting flowchart many many branches illegible. dtrackr detect issue pause tracking dataframe warning. user resume() tracking large number groups resolved e.g. using dplyr::ungroup(). limit configurable options(\"dtrackr.max_supported_groupings\"=XX). default 16. See dplyr::group_by().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_group_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stratifying your analysis — p_group_by","text":"","code":"p_group_by(   .data,   ...,   .messages = \"stratify by {.cols}\",   .headline = NULL,   .tag = NULL,   .maxgroups = .defaultMaxSupportedGroupings() )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_group_by.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stratifying your analysis — p_group_by","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... group_by(), variables computations group . Computations always done ungrouped data frame. perform computations grouped data, need use separate mutate() step group_by(). Computations allowed nest_by(). ungroup(), variables remove grouping.   Named arguments passed dplyr::group_by .add FALSE, default, group_by() override existing groups. add existing groups, use .add = TRUE. argument previously called add, prevented creating new grouping variable called add, conflicts naming conventions. .drop Drop groups formed factor levels appear data? default TRUE except .data previously grouped .drop = FALSE. See group_by_drop_default() details. x tbl() .messages set glue specs. glue code can use global variable, {.cols} columns grouped . .headline headline glue spec. glue code can use global variable, {.cols}. .tag want summary data step future give name .tag. .maxgroups maximum number subgroups allowed tracking paused.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_group_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stratifying your analysis — p_group_by","text":".data grouped.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_group_by.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stratifying your analysis — p_group_by","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% track() %>% group_by(Species, .messages=\"stratify by {.cols}\") tmp %>% comment(\"{.strata}\") %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Species:setosa\", \"Species:setosa\" #> ├ [Species:versicolor]: \"Species:versicolor\", \"Species:versicolor\" #> └ [Species:virginica]: \"Species:virginica\", \"Species:virginica\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_group_modify.html","id":null,"dir":"Reference","previous_headings":"","what":"Group-wise modification of data and complex operations — p_group_modify","title":"Group-wise modification of data and complex operations — p_group_modify","text":"Group modifying data set acts normal way. internal mechanics modify function opaque history. means can used wrap unsupported operation without losing history (e.g. df %>% track() %>% group_modify(function(d,...) { d %>% unsupported_operation() }) ) Prior operation size group calculated {.count.} operation output size {.count.} group {.strata} also available (grouped) reporting See dplyr::group_modify().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_group_modify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group-wise modification of data and complex operations — p_group_modify","text":"","code":"p_group_modify(   .data,   ...,   .messages = NULL,   .headline = .defaultHeadline(),   .type = \"modify\",   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_group_modify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group-wise modification of data and complex operations — p_group_modify","text":".data grouped tibble ... Additional arguments passed .f   Named arguments passed dplyr::group_modify .f function formula apply group. function, used . least 2 formal arguments. formula, e.g. ~ head(.x), converted function. formula, can use . .x refer subset rows .tbl given group .y refer key, one row tibble one column per grouping variable identifies group .keep grouping variables kept .x .messages set glue specs. glue code can use global variable, {.strata},{.count.},{.count.} .headline headline glue spec. glue code can use global variable, {.strata},{.count.},{.count.} .type default \"modify\": used define formatting .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_group_modify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group-wise modification of data and complex operations — p_group_modify","text":"transformed .data dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_group_modify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group-wise modification of data and complex operations — p_group_modify","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% track() %>% group_by(Species) tmp %>% group_modify(       function(d,g,...) { return(tibble::tibble(x=runif(10))) },       .messages=\"{.count.in} in, {.count.out} out\" ) %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Species:setosa\", \"50 in, 10 out\" #> ├ [Species:versicolor]: \"Species:versicolor\", \"50 in, 10 out\" #> └ [Species:virginica]: \"Species:virginica\", \"50 in, 10 out\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_include_any.html","id":null,"dir":"Reference","previous_headings":"","what":"Include any items matching a criteria — p_include_any","title":"Include any items matching a criteria — p_include_any","text":"Apply set inclusion criteria record actions filter dtrackr history graph. ... filter specification, parameters MUST NAMED. function opposite exclude_all() filtering criteria work identify rows include .e. results include anything match criteria. na.rm=TRUE also keep anything evaluated criteria.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_include_any.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Include any items matching a criteria — p_include_any","text":"","code":"p_include_any(   .data,   ...,   .headline = .defaultHeadline(),   na.rm = TRUE,   .type = \"inclusion\",   .asOffshoot = FALSE,   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_include_any.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Include any items matching a criteria — p_include_any","text":".data dataframe may grouped ... dplyr filter specification set formulae LHS predicates test data set , items match least one predicates included. RHS glue specification, defining message, entered history graph predicate matched. can refer grouping variables, variables environment {.included} {.matched} {.missing} (included = matched+missing), {.count} {.total} - group overall counts respectively, e.g. \"excluding {.matched} items {.missing} missing values\". .headline glue specification can refer grouping variables .data, variables defined calling environment na.rm (default TRUE) filter evaluated row count row missing either exclude (TRUE) exclude (FALSE) .type default \"inclusion\": used define formatting .asOffshoot want comment offshoot main flow (default = FALSE). .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_include_any.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Include any items matching a criteria — p_include_any","text":"filtered .data dataframe history graph updated summary included items new stage","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_include_any.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Include any items matching a criteria — p_include_any","text":"","code":"library(dplyr) library(dtrackr)  iris %>% track() %>% group_by(Species) %>% include_any(       Petal.Length > 5 ~ \"{.included} long ones\",       Petal.Length < 2 ~ \"{.included} short ones\" ) %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Species:setosa\", \"inclusions:\", \"0 long ones\", \"50 short ones\" #> ├ [Species:versicolor]: \"Species:versicolor\", \"inclusions:\", \"1 long ones\", \"0 short ones\" #> └ [Species:virginica]: \"Species:virginica\", \"inclusions:\", \"41 long ones\", \"0 short ones\"  # simultaneous evaluation of criteria: data.frame(a = 1:10) %>%   track() %>%   include_any(     # These two criteria identify the same value and one item is excluded     a > 1 ~ \"{.included} value > 1\",     a != min(a) ~ \"{.included} everything but the smallest value\",   ) %>%   status() %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"9 items\"  # the behaviour is equivalent to dplyr's filter function: data.frame(a=1:10) %>%   dplyr::filter(a > 1, a != min(a)) %>%   nrow() #> [1] 9  # step-wise evaluation of criteria results in a different output data.frame(a = 1:10) %>%   track() %>%   # Performing the same exclusion sequentially results in 2 items   # being excluded as the criteria no longer identify the same   # item.   include_any(a > 1 ~ \"{.included} value > 1\") %>%   include_any(a != min(a) ~ \"{.included} everything but the smallest value\") %>%   status() %>%   history() #> dtrackr history: #> number of flowchart steps: 4 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"8 items\"  # the behaviour is equivalent to dplyr's filter function: data.frame(a=1:10) %>%   dplyr::filter(a > 1) %>%   dplyr::filter(a != min(a)) %>%   nrow() #> [1] 8"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_inner_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Inner joins — p_inner_join","title":"Inner joins — p_inner_join","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::inner_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_inner_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inner joins — p_inner_join","text":"","code":"p_inner_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\",     \"{.count.out} in linked set\"),   .headline = \"Inner join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_inner_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inner joins — p_inner_join","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::inner_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . suffix non-joined duplicate variables x y, suffixes added output disambiguate . character vector length 2. keep join keys x y preserved output? NULL, default, joins equality retain keys x, joins inequality retain keys inputs. TRUE, keys inputs retained. FALSE, keys x retained. right full joins, data key columns corresponding rows exist y merged key columns x. used joining inequality conditions. na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). multiple Handling rows x multiple matches y. row x: \"\", default, returns every match detected y. behavior SQL. \"\" returns one match detected y, guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected y. \"last\" returns last match detected y. unmatched unmatched keys result dropped rows handled? \"drop\" drops unmatched keys result. \"error\" throws error unmatched keys detected. unmatched intended protect accidentally dropping rows join. checks unmatched keys input potentially drop rows. left joins, checks y. right joins, checks x. inner joins, checks x y. case, unmatched also allowed character vector length 2 specify behavior x y independently. relationship Handling expected relationship keys x y. expectations chosen list invalidated, error thrown. NULL, default, expect relationship x y. However, equality joins check many--many relationship (typically unexpected) warn one occurs, encouraging either take closer look inputs make relationship explicit specifying \"many--many\". See Many--many relationships section details. \"one--one\" expects: row x matches 1 row y. row y matches 1 row x. \"one--many\" expects: row y matches 1 row x. \"many--one\" expects: row x matches 1 row y. \"many--many\" perform relationship checks, provided allow explicit relationship know exists. relationship handle cases zero matches. , see unmatched. .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_inner_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inner joins — p_inner_join","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_inner_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inner joins — p_inner_join","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Inner join join = lhs %>% inner_join(rhs, by=\"name\", multiple = \"all\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() %>% print() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 173\" nrow(join) #> [1] 173 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_intersect.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — p_intersect","title":"Set operations — p_intersect","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_intersect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — p_intersect","text":"","code":"p_intersect(   x,   y,   ...,   .messages = \"{.count.out} in intersection\",   .headline = \"Intersection\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_intersect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — p_intersect","text":"x, y Vectors combine. ... collection tracked data frames combine .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_intersect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — p_intersect","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_intersect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — p_intersect","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_left_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Left join — p_left_join","title":"Left join — p_left_join","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::left_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_left_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Left join — p_left_join","text":"","code":"p_left_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\",     \"{.count.out} in linked set\"),   .headline = \"Left join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_left_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Left join — p_left_join","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::left_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . suffix non-joined duplicate variables x y, suffixes added output disambiguate . character vector length 2. keep join keys x y preserved output? NULL, default, joins equality retain keys x, joins inequality retain keys inputs. TRUE, keys inputs retained. FALSE, keys x retained. right full joins, data key columns corresponding rows exist y merged key columns x. used joining inequality conditions. na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). multiple Handling rows x multiple matches y. row x: \"\", default, returns every match detected y. behavior SQL. \"\" returns one match detected y, guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected y. \"last\" returns last match detected y. unmatched unmatched keys result dropped rows handled? \"drop\" drops unmatched keys result. \"error\" throws error unmatched keys detected. unmatched intended protect accidentally dropping rows join. checks unmatched keys input potentially drop rows. left joins, checks y. right joins, checks x. inner joins, checks x y. case, unmatched also allowed character vector length 2 specify behavior x y independently. relationship Handling expected relationship keys x y. expectations chosen list invalidated, error thrown. NULL, default, expect relationship x y. However, equality joins check many--many relationship (typically unexpected) warn one occurs, encouraging either take closer look inputs make relationship explicit specifying \"many--many\". See Many--many relationships section details. \"one--one\" expects: row x matches 1 row y. row y matches 1 row x. \"one--many\" expects: row y matches 1 row x. \"many--one\" expects: row x matches 1 row y. \"many--many\" perform relationship checks, provided allow explicit relationship know exists. relationship handle cases zero matches. , see unmatched. .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_left_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Left join — p_left_join","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_left_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Left join — p_left_join","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Left join join = lhs %>% left_join(rhs, by=\"name\", multiple = \"all\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 173\" nrow(join) #> [1] 173 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_mutate.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — p_mutate","title":"dplyr modifying operations — p_mutate","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_mutate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — p_mutate","text":"","code":"p_mutate(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_mutate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — p_mutate","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. Named arguments passed dplyr::mutate . <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .keep Control columns .data retained output. Grouping columns columns created ... always kept. \"\" retains columns .data. default. \"used\" retains columns used ... create new columns. useful checking work, displays inputs outputs side--side. \"unused\" retains columns used ... create new columns. useful generate new columns, longer need columns used generate . \"none\" retain extra columns .data. grouping variables columns created ... kept. .,.<tidy-select> Optionally, control new columns appear (default add right hand side). See relocate() details. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_mutate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — p_mutate","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_mutate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — p_mutate","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # mutate # In this example we compare the column names of the input and the # output to identify the new columns created by the mutate operation as # the `.new_cols` variable iris %>%   track() %>%   mutate(extra_col = NA_real_,          .messages=\"{.new_cols}\",          .headline=\"Extra columns from mutate:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"Extra columns from mutate:\", \"extra_col\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_nest_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Nest join — p_nest_join","title":"Nest join — p_nest_join","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::nest_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_nest_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nest join — p_nest_join","text":"","code":"p_nest_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\", \"{.count.out} matched\"),   .headline = \"Nest join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_nest_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nest join — p_nest_join","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::nest_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . keep new list-column contain join keys? default preserve join keys inequality joins. name name list-column created join. NULL, default, name y used. na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). unmatched unmatched keys result dropped rows handled? \"drop\" drops unmatched keys result. \"error\" throws error unmatched keys detected. unmatched intended protect accidentally dropping rows join. checks unmatched keys input potentially drop rows. left joins, checks y. right joins, checks x. inner joins, checks x y. case, unmatched also allowed character vector length 2 specify behavior x y independently. .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_nest_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nest join — p_nest_join","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_nest_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nest join — p_nest_join","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Nest join join = lhs %>% nest_join(rhs, by=\"name\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() %>% print() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 87\" nrow(join) #> [1] 87 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pause.html","id":null,"dir":"Reference","previous_headings":"","what":"Pause tracking the data frame. — p_pause","title":"Pause tracking the data frame. — p_pause","text":"Pausing tracking data frame may required operation performed creates lot groupings otherwise want pollute history graph (e.g. maybe selecting something using anti-join). paused history updated resume() called, data frame ungrouped (auto enabled).","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pause.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pause tracking the data frame. — p_pause","text":"","code":"p_pause(.data, auto = FALSE)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pause.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pause tracking the data frame. — p_pause","text":".data tracked dataframe auto TRUE tracking resume automatically number groups fallen sensible level (default FALSE)?","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pause.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pause tracking the data frame. — p_pause","text":".data dataframe history graph tracking paused","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pause.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pause tracking the data frame. — p_pause","text":"","code":"iris %>% track() %>% pause() %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"150 items\" #> TRACKING IS PAUSED (manual)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pivot_longer.html","id":null,"dir":"Reference","previous_headings":"","what":"Reshaping data using tidyr::pivot_longer — p_pivot_longer","title":"Reshaping data using tidyr::pivot_longer — p_pivot_longer","text":"drop replacement tidyr::pivot_longer() optionally takes message headline store history graph.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pivot_longer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reshaping data using tidyr::pivot_longer — p_pivot_longer","text":"","code":"p_pivot_longer(data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pivot_longer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reshaping data using tidyr::pivot_longer — p_pivot_longer","text":"data data frame pivot. ... Additional arguments passed methods.   Named arguments passed tidyr::pivot_longer cols <tidy-select> Columns pivot longer format. cols_vary pivoting cols longer format, output rows arranged relative original row number? \"fastest\", default, keeps individual rows cols close together output. often produces intuitively ordered output least one key column data involved pivoting process. \"slowest\" keeps individual columns cols close together output. often produces intuitively ordered output utilize columns data pivoting process. names_to character vector specifying new column columns create information stored column names data specified cols. length 0, NULL supplied, columns created. length 1, single column created contain column names specified cols. length >1, multiple columns created. case, one names_sep names_pattern must supplied specify column names split. also two additional character values can take advantage : NA discard corresponding component column name. \".value\" indicates corresponding component column name defines name output column containing cell values, overriding values_to entirely. names_prefix regular expression used remove matching text start variable name. names_sep,names_pattern names_to contains multiple values, arguments control column name broken . names_sep takes specification separate(), can either numeric vector (specifying positions break ), single string (specifying regular expression split ). names_pattern takes specification extract(), regular expression containing matching groups (()). arguments give enough control, use pivot_longer_spec() create spec object process manually needed. names_ptypes,values_ptypes Optionally, list column name-prototype pairs. Alternatively, single empty prototype can supplied, applied columns. prototype (ptype short) zero-length vector (like integer() numeric()) defines type, class, attributes vector. Use arguments want confirm created columns types expect. Note want change (instead confirm) types specific columns, use names_transform values_transform instead. names_transform,values_transform Optionally, list column name-function pairs. Alternatively, single function can supplied, applied columns. Use arguments need change types specific columns. example, names_transform = list(week = .integer) convert character variable called week integer. specified, type columns generated names_to character, type variables generated values_to common type input columns used generate . names_repair happens output invalid column names? default, \"check_unique\" error columns duplicated. Use \"minimal\" allow duplicates output, \"unique\" de-duplicated adding numeric suffixes. See vctrs::vec_as_names() options. values_to string specifying name column create data stored cell values. names_to character containing special .value sentinel, value ignored, name value column derived part existing column names. values_drop_na TRUE, drop rows contain NAs value_to column. effectively converts explicit missing values implicit missing values, generally used missing values data created structure. .messages set glue specs. glue code can use global variable, grouping variable, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pivot_longer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reshaping data using tidyr::pivot_longer — p_pivot_longer","text":"result tidyr::pivot_longer history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pivot_wider.html","id":null,"dir":"Reference","previous_headings":"","what":"Reshaping data using tidyr::pivot_wider — p_pivot_wider","title":"Reshaping data using tidyr::pivot_wider — p_pivot_wider","text":"drop replacement tidyr::pivot_wider() optionally takes message headline store history graph.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pivot_wider.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reshaping data using tidyr::pivot_wider — p_pivot_wider","text":"","code":"p_pivot_wider(data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pivot_wider.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reshaping data using tidyr::pivot_wider — p_pivot_wider","text":"data data frame pivot. ... Additional arguments passed methods.   Named arguments passed tidyr::pivot_wider id_cols <tidy-select> set columns uniquely identify observation. Typically used redundant variables, .e. variables whose values perfectly correlated existing variables. Defaults columns data except columns specified names_from values_from. tidyselect expression supplied, evaluated data removing columns specified names_from values_from. id_expand values id_cols columns expanded expand() pivoting? results rows, output contain complete expansion possible values id_cols. Implicit factor levels represented data become explicit. Additionally, row values corresponding expanded id_cols sorted. names_from,values_from <tidy-select> pair arguments describing column (columns) get name output column (names_from), column (columns) get cell values (values_from). values_from contains multiple values, value added front output column. names_prefix String added start every variable name. particularly useful names_from numeric vector want create syntactic variable names. names_sep names_from values_from contains multiple variables, used join values together single string use column name. names_glue Instead names_sep names_prefix, can supply glue specification uses names_from columns (special .value) create custom column names. names_sort column names sorted? FALSE, default, column names ordered first appearance. names_vary names_from identifies column (columns) multiple unique values, multiple values_from columns provided, order resulting column names combined? \"fastest\" varies names_from values fastest, resulting column naming scheme form: value1_name1, value1_name2, value2_name1, value2_name2. default. \"slowest\" varies names_from values slowest, resulting column naming scheme form: value1_name1, value2_name1, value1_name2, value2_name2. names_expand values names_from columns expanded expand() pivoting? results columns, output contain column names corresponding complete expansion possible values names_from. Implicit factor levels represented data become explicit. Additionally, column names sorted, identical names_sort produce. names_repair happens output invalid column names? default, \"check_unique\" error columns duplicated. Use \"minimal\" allow duplicates output, \"unique\" de-duplicated adding numeric suffixes. See vctrs::vec_as_names() options. values_fill Optionally, (scalar) value specifies value filled missing. can named list want apply different fill values different value columns. values_fn Optionally, function applied value cell output. typically use combination id_cols names_from columns uniquely identify observation. can named list want apply different aggregations different values_from columns. unused_fn Optionally, function applied summarize values unused columns (.e. columns identified id_cols, names_from, values_from). default drops unused columns result. can named list want apply different aggregations different unused columns. id_cols must supplied unused_fn useful, since otherwise unspecified columns considered id_cols. similar grouping id_cols summarizing unused columns using unused_fn. .messages set glue specs. glue code can use global variable, grouping variable, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_pivot_wider.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reshaping data using tidyr::pivot_wider — p_pivot_wider","text":"data dataframe result tidyr::pivot_wider function history graph updated .message requested.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_reframe.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise a data set — p_reframe","title":"Summarise a data set — p_reframe","text":"Summarising data set acts normal dplyr manner collapse groups individual rows. columns resulting summary can added history graph. history also joins stratified branches allows generate summary statistics un-grouped data. See dplyr::summarise().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_reframe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise a data set — p_reframe","text":"","code":"p_reframe(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_reframe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise a data set — p_reframe","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs summary functions. name name variable result. value can : vector length 1, e.g. min(x), n(), sum(.na(y)). data frame, add multiple columns single expression. Returning values size 0 >1 deprecated 1.1.0. Please use reframe() instead.   Named arguments passed dplyr::reframe . <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .messages set glue specs. glue code can use summary variable defined ... parameter, global variable, {.strata} .headline headline glue spec. glue code can use summary variable defined ... parameter, global variable, {.strata} .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_reframe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise a data set — p_reframe","text":".data dataframe summarised history graph updated showing summarise operation new stage","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_reframe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise a data set — p_reframe","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% group_by(Species) %>% track() tmp %>% reframe(tibble(   param = c(\"mean\",\"min\",\"max\"),   value = c(mean(Petal.Length), min(Petal.Length), max(Petal.Length))   ), .messages=\"length {param}: {value}\") %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"length mean: 1.462\", \"length min: 1\", \"length max: 1.9\" #> ├ [Species:versicolor]: \"length mean: 4.26\", \"length min: 3\", \"length max: 5.1\" #> └ [Species:virginica]: \"length mean: 5.552\", \"length min: 4.5\", \"length max: 6.9\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_relocate.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — p_relocate","title":"dplyr modifying operations — p_relocate","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_relocate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — p_relocate","text":"","code":"p_relocate(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_relocate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — p_relocate","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. Named arguments passed dplyr::relocate .,.<tidy-select> Destination columns selected .... Supplying neither move columns left-hand side; specifying error. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_relocate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — p_relocate","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_relocate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — p_relocate","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # relocate, this shows how the columns can be reordered iris %>%   track() %>%   group_by(Species) %>%   relocate(     tidyselect::starts_with(\"Sepal\"),     .after=Species,     .messages=\"{.cols}\",     .headline=\"Order of columns from relocate:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Order of columns from relocate:\", \"Petal.Length, Petal.Width, Species, Sepal.Length, Sepal.Width\" #> ├ [Species:versicolor]: \"Order of columns from relocate:\", \"Petal.Length, Petal.Width, Species, Sepal.Length, Sepal.Width\" #> └ [Species:virginica]: \"Order of columns from relocate:\", \"Petal.Length, Petal.Width, Species, Sepal.Length, Sepal.Width\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_rename.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — p_rename","title":"dplyr modifying operations — p_rename","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_rename.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — p_rename","text":"","code":"p_rename(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_rename.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — p_rename","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. Named arguments passed dplyr::rename .fn function used transform selected .cols. return character vector length input. .cols <tidy-select> Columns rename; defaults columns. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_rename.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — p_rename","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_rename.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — p_rename","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # rename can show us which columns are new and which have been # removed (with .dropped_cols) iris %>%   track() %>%   group_by(Species) %>%   rename(     Stamen.Width = Sepal.Width,     Stamen.Length = Sepal.Length,     .messages=c(\"added {.new_cols}\",\"dropped {.dropped_cols}\"),     .headline=\"Renamed columns:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\" #> ├ [Species:versicolor]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\" #> └ [Species:virginica]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_rename_with.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — p_rename_with","title":"dplyr modifying operations — p_rename_with","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_rename_with.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — p_rename_with","text":"","code":"p_rename_with(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_rename_with.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — p_rename_with","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. Named arguments passed dplyr::rename_with .fn function used transform selected .cols. return character vector length input. .cols <tidy-select> Columns rename; defaults columns. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_rename_with.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — p_rename_with","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_rename_with.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — p_rename_with","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # rename can show us which columns are new and which have been # removed (with .dropped_cols) iris %>%   track() %>%   group_by(Species) %>%   rename(     Stamen.Width = Sepal.Width,     Stamen.Length = Sepal.Length,     .messages=c(\"added {.new_cols}\",\"dropped {.dropped_cols}\"),     .headline=\"Renamed columns:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\" #> ├ [Species:versicolor]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\" #> └ [Species:virginica]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_resume.html","id":null,"dir":"Reference","previous_headings":"","what":"Resume tracking the data frame. — p_resume","title":"Resume tracking the data frame. — p_resume","text":"may reset grouping tracked data grouping structure changed since data frame paused. try resume tracking data frame many groups (defined options(\"dtrackr.max_supported_groupings\"=XX)) resume fail data frame still paused. can overridden specifying value .maxgroups parameter.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_resume.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resume tracking the data frame. — p_resume","text":"","code":"p_resume(.data, ...)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_resume.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resume tracking the data frame. — p_resume","text":".data tracked dataframe ... Named arguments passed p_group_by .messages set glue specs. glue code can use global variable, {.cols} columns grouped . .headline headline glue spec. glue code can use global variable, {.cols}. .tag want summary data step future give name .tag. .maxgroups maximum number subgroups allowed tracking paused. ... group_by(), variables computations group . Computations always done ungrouped data frame. perform computations grouped data, need use separate mutate() step group_by(). Computations allowed nest_by(). ungroup(), variables remove grouping.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_resume.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resume tracking the data frame. — p_resume","text":".data data frame history graph tracking resumed","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_resume.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Resume tracking the data frame. — p_resume","text":"","code":"library(dplyr) library(dtrackr) iris %>% track() %>% pause() %>% resume() %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"150 items\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_right_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Right join — p_right_join","title":"Right join — p_right_join","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::right_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_right_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Right join — p_right_join","text":"","code":"p_right_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\",     \"{.count.out} in linked set\"),   .headline = \"Right join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_right_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Right join — p_right_join","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::right_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . suffix non-joined duplicate variables x y, suffixes added output disambiguate . character vector length 2. keep join keys x y preserved output? NULL, default, joins equality retain keys x, joins inequality retain keys inputs. TRUE, keys inputs retained. FALSE, keys x retained. right full joins, data key columns corresponding rows exist y merged key columns x. used joining inequality conditions. na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). multiple Handling rows x multiple matches y. row x: \"\", default, returns every match detected y. behavior SQL. \"\" returns one match detected y, guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected y. \"last\" returns last match detected y. unmatched unmatched keys result dropped rows handled? \"drop\" drops unmatched keys result. \"error\" throws error unmatched keys detected. unmatched intended protect accidentally dropping rows join. checks unmatched keys input potentially drop rows. left joins, checks y. right joins, checks x. inner joins, checks x y. case, unmatched also allowed character vector length 2 specify behavior x y independently. relationship Handling expected relationship keys x y. expectations chosen list invalidated, error thrown. NULL, default, expect relationship x y. However, equality joins check many--many relationship (typically unexpected) warn one occurs, encouraging either take closer look inputs make relationship explicit specifying \"many--many\". See Many--many relationships section details. \"one--one\" expects: row x matches 1 row y. row y matches 1 row x. \"one--many\" expects: row y matches 1 row x. \"many--one\" expects: row x matches 1 row y. \"many--many\" perform relationship checks, provided allow explicit relationship know exists. relationship handle cases zero matches. , see unmatched. .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_right_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Right join — p_right_join","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_right_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Right join — p_right_join","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Full join join = lhs %>% full_join(rhs, by=\"name\", multiple = \"all\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 173\" nrow(join) #> [1] 173 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_select.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — p_select","title":"dplyr modifying operations — p_select","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_select.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — p_select","text":"","code":"p_select(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_select.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — p_select","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_select.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — p_select","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_select.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — p_select","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # select # The output of the select verb (here using tidyselect syntax) can be captured # and here all column names are being reported with the .cols variable. iris %>%   track() %>%   group_by(Species) %>%   select(     tidyselect::starts_with(\"Sepal\"),     .messages=\"{.cols}\",     .headline=\"Output columns from select:\") %>%   history() #> Adding missing grouping variables: `Species` #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Output columns from select:\", \"Species, Sepal.Length, Sepal.Width\" #> ├ [Species:versicolor]: \"Output columns from select:\", \"Species, Sepal.Length, Sepal.Width\" #> └ [Species:virginica]: \"Output columns from select:\", \"Species, Sepal.Length, Sepal.Width\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_semi_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi join — p_semi_join","title":"Semi join — p_semi_join","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::semi_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_semi_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi join — p_semi_join","text":"","code":"p_semi_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\",     \"{.count.out} in intersection\"),   .headline = \"Semi join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_semi_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi join — p_semi_join","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::semi_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_semi_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi join — p_semi_join","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_semi_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi join — p_semi_join","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Semi join join = lhs %>% semi_join(rhs, by=\"name\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() %>% print() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 87\" nrow(join) #> [1] 87 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the dtrackr history graph — p_set","title":"Set the dtrackr history graph — p_set","text":"unlikely useful end user called automatically many functions . chance need copy history metadata one dataframe another","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the dtrackr history graph — p_set","text":"","code":"p_set(.data, .graph)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the dtrackr history graph — p_set","text":".data dataframe may grouped .graph history graph list (consisting nodes, edges, head) see examples","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the dtrackr history graph — p_set","text":".data dataframe history graph metadata set provided value","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set the dtrackr history graph — p_set","text":"","code":"library(dplyr) library(dtrackr) mtcars %>% p_set(iris %>% comment(\"A comment\") %>% p_get()) %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"A comment\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_setdiff.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — p_setdiff","title":"Set operations — p_setdiff","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_setdiff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — p_setdiff","text":"","code":"p_setdiff(   x,   y,   ...,   .messages = \"{.count.out} items in difference\",   .headline = \"Difference\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_setdiff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — p_setdiff","text":"x, y Vectors combine. ... collection tracked data frames combine .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_setdiff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — p_setdiff","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_setdiff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — p_setdiff","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — p_slice","title":"Slice operations — p_slice","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — p_slice","text":"","code":"p_slice(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — p_slice","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — p_slice","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — p_slice","text":"","code":"library(dplyr) library(dtrackr)  # an arbitrary 50 items from the iris dataframe is selected. The # history is tracked iris %>% track() %>% slice(51:100) %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"slice data\", \"150 before\", \"50 after\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_head.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — p_slice_head","title":"Slice operations — p_slice_head","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_head.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — p_slice_head","text":"","code":"p_slice_head(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_head.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — p_slice_head","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice_head ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_head.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — p_slice_head","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_head.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — p_slice_head","text":"","code":"library(dplyr) library(dtrackr)  # the first 50% of the data frame, is taken and the history tracked iris %>% track() %>% group_by(Species) %>%   slice_head(prop=0.5,.messages=\"{.count.out} / {.count.in}\",              .headline=\"First {sprintf('%1.0f',prop*100)}%\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"First 50%\", \"25 / 50\" #> ├ [Species:versicolor]: \"First 50%\", \"25 / 50\" #> └ [Species:virginica]: \"First 50%\", \"25 / 50\"  # The last 100 items: iris %>% track() %>% group_by(Species) %>%   slice_tail(n=100,.messages=\"{.count.out} / {.count.in}\",              .headline=\"Last 100\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Last 100\", \"50 / 50\" #> ├ [Species:versicolor]: \"Last 100\", \"50 / 50\" #> └ [Species:virginica]: \"Last 100\", \"50 / 50\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_max.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — p_slice_max","title":"Slice operations — p_slice_max","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_max.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — p_slice_max","text":"","code":"p_slice_max(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_max.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — p_slice_max","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice_max ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_max.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — p_slice_max","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_max.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — p_slice_max","text":"","code":"library(dplyr) library(dtrackr)   # Subset the data by the maximum of a given value iris %>% track() %>% group_by(Species) %>%   slice_max(prop=0.5, order_by = Sepal.Width,             .messages=\"{.count.out} / {.count.in} = {prop} (with ties)\",             .headline=\"Widest 50% Sepals\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Widest 50% Sepals\", \"31 / 50 = 0.5 (with ties)\" #> ├ [Species:versicolor]: \"Widest 50% Sepals\", \"29 / 50 = 0.5 (with ties)\" #> └ [Species:virginica]: \"Widest 50% Sepals\", \"29 / 50 = 0.5 (with ties)\"   # The narrowest 25% of the iris data set by group can be calculated in the # slice_min() function. Recording this is a matter of tracking and # using glue specs. iris %>%   track() %>%   group_by(Species) %>%   slice_min(prop=0.25, order_by = Sepal.Width,             .messages=\"{.count.out} / {.count.in} (with ties)\",             .headline=\"narrowest {sprintf('%1.0f',prop*100)}% {Species}\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"narrowest 25% setosa\", \"12 / 50 (with ties)\" #> ├ [Species:versicolor]: \"narrowest 25% versicolor\", \"13 / 50 (with ties)\" #> └ [Species:virginica]: \"narrowest 25% virginica\", \"19 / 50 (with ties)\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_min.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — p_slice_min","title":"Slice operations — p_slice_min","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_min.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — p_slice_min","text":"","code":"p_slice_min(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_min.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — p_slice_min","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice_min ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_min.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — p_slice_min","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_min.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — p_slice_min","text":"","code":"library(dplyr) library(dtrackr)   # Subset the data by the maximum of a given value iris %>% track() %>% group_by(Species) %>%   slice_max(prop=0.5, order_by = Sepal.Width,             .messages=\"{.count.out} / {.count.in} = {prop} (with ties)\",             .headline=\"Widest 50% Sepals\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Widest 50% Sepals\", \"31 / 50 = 0.5 (with ties)\" #> ├ [Species:versicolor]: \"Widest 50% Sepals\", \"29 / 50 = 0.5 (with ties)\" #> └ [Species:virginica]: \"Widest 50% Sepals\", \"29 / 50 = 0.5 (with ties)\"   # The narrowest 25% of the iris data set by group can be calculated in the # slice_min() function. Recording this is a matter of tracking and # using glue specs. iris %>%   track() %>%   group_by(Species) %>%   slice_min(prop=0.25, order_by = Sepal.Width,             .messages=\"{.count.out} / {.count.in} (with ties)\",             .headline=\"narrowest {sprintf('%1.0f',prop*100)}% {Species}\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"narrowest 25% setosa\", \"12 / 50 (with ties)\" #> ├ [Species:versicolor]: \"narrowest 25% versicolor\", \"13 / 50 (with ties)\" #> └ [Species:virginica]: \"narrowest 25% virginica\", \"19 / 50 (with ties)\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_sample.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — p_slice_sample","title":"Slice operations — p_slice_sample","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — p_slice_sample","text":"","code":"p_slice_sample(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — p_slice_sample","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice_sample ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — p_slice_sample","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_sample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — p_slice_sample","text":"","code":"library(dplyr) library(dtrackr)  # In this example the iris dataframe is resampled 100 times with replacement # within each group and the iris %>%   track() %>%   group_by(Species) %>%   slice_sample(n=100, replace=TRUE,                .messages=\"{.count.out} / {.count.in} = {n}\",                .headline=\"100 {Species}\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"100 setosa\", \"100 / 50 = 100\" #> ├ [Species:versicolor]: \"100 versicolor\", \"100 / 50 = 100\" #> └ [Species:virginica]: \"100 virginica\", \"100 / 50 = 100\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_tail.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — p_slice_tail","title":"Slice operations — p_slice_tail","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_tail.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — p_slice_tail","text":"","code":"p_slice_tail(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_tail.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — p_slice_tail","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice_tail ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_tail.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — p_slice_tail","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_slice_tail.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — p_slice_tail","text":"","code":"library(dplyr) library(dtrackr)  # the first 50% of the data frame, is taken and the history tracked iris %>% track() %>% group_by(Species) %>%   slice_head(prop=0.5,.messages=\"{.count.out} / {.count.in}\",              .headline=\"First {sprintf('%1.0f',prop*100)}%\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"First 50%\", \"25 / 50\" #> ├ [Species:versicolor]: \"First 50%\", \"25 / 50\" #> └ [Species:virginica]: \"First 50%\", \"25 / 50\"  # The last 100 items: iris %>% track() %>% group_by(Species) %>%   slice_tail(n=100,.messages=\"{.count.out} / {.count.in}\",              .headline=\"Last 100\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Last 100\", \"50 / 50\" #> ├ [Species:versicolor]: \"Last 100\", \"50 / 50\" #> └ [Species:virginica]: \"Last 100\", \"50 / 50\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a summary to the dtrackr history graph — p_status","title":"Add a summary to the dtrackr history graph — p_status","text":"middle pipeline may wish document something data complex simple counts. status essentially dplyr summarisation step connected glue specification output, recorded data frame history. means can arbitrary interim summarisation put result flowchart without disrupting pipeline flow.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a summary to the dtrackr history graph — p_status","text":"","code":"p_status(   .data,   ...,   .messages = .defaultMessage(),   .headline = .defaultHeadline(),   .type = \"info\",   .asOffshoot = FALSE,   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a summary to the dtrackr history graph — p_status","text":".data dataframe may grouped ... normal dplyr::summarise specification, e.g. count=n() av=mean(x), etcetera. .messages character vector glue specifications. glue specification can refer summary outputs, grouping variables .data, {.strata}, variables defined calling environment .headline glue specification can refer grouping variables .data, variables defined calling environment .type one \"info\",\"exclusion\": used define formatting .asOffshoot want comment offshoot main flow (default = FALSE). .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a summary to the dtrackr history graph — p_status","text":".data dataframe history metadata updated status inserted new stage","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_status.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a summary to the dtrackr history graph — p_status","text":"... summary specification parameters MUST NAMED.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_status.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a summary to the dtrackr history graph — p_status","text":"","code":"library(dplyr) library(dtrackr) tmp = iris %>% track() %>% group_by(Species) tmp %>% status(       long = p_count_if(Petal.Length>5),       short = p_count_if(Petal.Length<2),       .messages=\"{Species}: {long} long ones & {short} short ones\" ) %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Species:setosa\", \"setosa: 0 long ones &amp; 50 short ones\" #> ├ [Species:versicolor]: \"Species:versicolor\", \"versicolor: 1 long ones &amp; 0 short ones\" #> └ [Species:virginica]: \"Species:virginica\", \"virginica: 41 long ones &amp; 0 short ones\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_summarise.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise a data set — p_summarise","title":"Summarise a data set — p_summarise","text":"Summarising data set acts normal dplyr manner collapse groups individual rows. columns resulting summary can added history graph. history also joins stratified branches allows generate summary statistics un-grouped data. See dplyr::summarise().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_summarise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise a data set — p_summarise","text":"","code":"p_summarise(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_summarise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise a data set — p_summarise","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs summary functions. name name variable result. value can : vector length 1, e.g. min(x), n(), sum(.na(y)). data frame, add multiple columns single expression. Returning values size 0 >1 deprecated 1.1.0. Please use reframe() instead.   Named arguments passed dplyr::summarise . <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .groups Grouping structure result. \"drop_last\": dropping last level grouping. supported option version 1.0.0. \"drop\": levels grouping dropped. \"keep\": grouping structure .data. \"rowwise\": row group. .groups specified, chosen based number rows results: results 1 row, get \"drop_last\". number rows varies, get \"keep\" (note returning variable number rows deprecated favor reframe(), also unconditionally drops levels grouping). addition, message informs choice, unless result ungrouped, option \"dplyr.summarise.inform\" set FALSE, summarise() called function package. .messages set glue specs. glue code can use summary variable defined ... parameter, global variable, {.strata} .headline headline glue spec. glue code can use summary variable defined ... parameter, global variable, {.strata} .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_summarise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise a data set — p_summarise","text":".data dataframe summarised history graph updated showing summarise operation new stage","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_summarise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise a data set — p_summarise","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% group_by(Species) %>% track() tmp %>% summarise(avg = mean(Petal.Length), .messages=\"{avg} length\") %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"1.462 length\" #> ├ [Species:versicolor]: \"4.26 length\" #> └ [Species:virginica]: \"5.552 length\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_tagged.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve tagged data in the history graph — p_tagged","title":"Retrieve tagged data in the history graph — p_tagged","text":"counts individual stages stored .tag option pipeline step can recovered . idea provide quick way access single value counts details tagged pipeline format can reported text document. (e.g. results section). examples consort statement vignette examples use.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_tagged.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve tagged data in the history graph — p_tagged","text":"","code":"p_tagged(.data, .tag = NULL, .strata = NULL, .glue = NULL, ...)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_tagged.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve tagged data in the history graph — p_tagged","text":".data tracked dataframe. .tag (optional) tag retrieve. .strata (optional) filter tagged data strata. set \"\" filter just top level ungrouped data. .glue (optional) glue specification applied tagged content generate .label tagged content. ... (optional) named parameters passed glue::glue can used generate label.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_tagged.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve tagged data in the history graph — p_tagged","text":"various things depending requested. default tibble .tag column associated summary values nested .content column. .strata column specified results filtered just match given .strata grouping (.e. grouping label flowchart). Ungrouped content empty \"\" .strata .tag specified result single tag .content automatically un-nested give single un-nested dataframe content captured .tag tagged step. single multiple rows depending whether original data grouped point tagging. .tag .glue specified .label column computed .glue tagged content. result single row just string value .label returned. just .glue specified, un-nested dataframe .tag,.strata .label columns label tag strata. seems complex best thing experiment get output want, leaving .glue options think know . made sense time.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_tagged.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve tagged data in the history graph — p_tagged","text":"","code":"library(dplyr) library(dtrackr) tmp = iris %>% track() %>% comment(.tag = \"step1\") tmp = tmp %>% filter(Species!=\"versicolor\") %>% group_by(Species) tmp %>% comment(.tag=\"step2\") %>% tagged(.glue = \"{.count}/{.total}\") #> # A tibble: 3 × 3 #>   .tag  .strata             .label  #>   <chr> <chr>               <glue>  #> 1 step1 \"\"                  150/150 #> 2 step2 \"Species:setosa\"    50/100  #> 3 step2 \"Species:virginica\" 50/100"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_track.html","id":null,"dir":"Reference","previous_headings":"","what":"Start tracking the dtrackr history graph — p_track","title":"Start tracking the dtrackr history graph — p_track","text":"Start tracking dtrackr history graph","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_track.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Start tracking the dtrackr history graph — p_track","text":"","code":"p_track(   .data,   .messages = .defaultMessage(),   .headline = .defaultHeadline(),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_track.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Start tracking the dtrackr history graph — p_track","text":".data dataframe may grouped .messages character vector glue specifications. glue specification can refer grouping variables .data, variables defined calling environment, {.total} variable count rows, {.count} variable count rows current group {.strata} describes current group. Defaults value getOption(\"dtrackr.default_message\"). .headline glue specification can refer grouping variables .data, variables defined calling environment, {.total} variable nrow(.data), {.strata} summary current group. Defaults value getOption(\"dtrackr.default_headline\"). .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_track.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Start tracking the dtrackr history graph — p_track","text":".data dataframe additional history graph metadata, allow tracking.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_track.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Start tracking the dtrackr history graph — p_track","text":"","code":"library(dplyr) library(dtrackr) iris %>% track() %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"150 items\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_transmute.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — p_transmute","title":"dplyr modifying operations — p_transmute","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_transmute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — p_transmute","text":"","code":"p_transmute(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_transmute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — p_transmute","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_transmute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — p_transmute","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_transmute.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — p_transmute","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # In this example we compare the column names of the input and the # output to identify the new columns created by the transmute operation as # the `.new_cols` variable # Here we do the same for a transmute() iris %>%   track() %>%   group_by(Species, .add=TRUE) %>%   transmute(     sepal.w = Sepal.Width-1,     sepal.l = Sepal.Length+1,     .messages=\"{.new_cols}\",     .headline=\"New columns from transmute:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"New columns from transmute:\", \"sepal.w, sepal.l\" #> ├ [Species:versicolor]: \"New columns from transmute:\", \"sepal.w, sepal.l\" #> └ [Species:virginica]: \"New columns from transmute:\", \"sepal.w, sepal.l\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_ungroup.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove a stratification from a data set — p_ungroup","title":"Remove a stratification from a data set — p_ungroup","text":"Un-grouping data set logically combines different arms. history joins stratified branches acts specific type status(), allowing generate summary statistics un-grouped data. See dplyr::ungroup().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_ungroup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove a stratification from a data set — p_ungroup","text":"","code":"p_ungroup(   x,   ...,   .messages = .defaultMessage(),   .headline = .defaultHeadline(),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_ungroup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove a stratification from a data set — p_ungroup","text":"x tbl() ... variables remove grouping. .messages set glue specs. glue code can use global variable, {.count}. default \"total {.count} items\" .headline headline glue spec. glue code can use {.count} {.strata}. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_ungroup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove a stratification from a data set — p_ungroup","text":".data dataframe ungrouped history graph updated showing ungroup operation new stage.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_ungroup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove a stratification from a data set — p_ungroup","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% group_by(Species) %>% comment(\"A test\") tmp %>% ungroup(.messages=\"{.count} items in combined\") %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"150 items in combined\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_union.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — p_union","title":"Set operations — p_union","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_union.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — p_union","text":"","code":"p_union(   x,   y,   ...,   .messages = \"{.count.out} unique items in union\",   .headline = \"Distinct union\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_union.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — p_union","text":"x, y Vectors combine. ... collection tracked data frames combine .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_union.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — p_union","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_union.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — p_union","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_union_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — p_union_all","title":"Set operations — p_union_all","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_union_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — p_union_all","text":"","code":"p_union_all(   x,   y,   ...,   .messages = \"{.count.out} items in union\",   .headline = \"Union\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_union_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — p_union_all","text":"x, y Pair compatible data frames. pair data frames compatible column names (possibly different orders) compatible types. ... collection tracked data frames combine .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_union_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — p_union_all","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_union_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — p_union_all","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_untrack.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove tracking from the dataframe — p_untrack","title":"Remove tracking from the dataframe — p_untrack","text":"Remove tracking dataframe","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_untrack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove tracking from the dataframe — p_untrack","text":"","code":"p_untrack(.data)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_untrack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove tracking from the dataframe — p_untrack","text":".data tracked dataframe","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_untrack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove tracking from the dataframe — p_untrack","text":".data dataframe history graph metadata removed.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/p_untrack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove tracking from the dataframe — p_untrack","text":"","code":"library(dplyr) library(dtrackr) iris %>% track() %>% untrack() %>% class() #> [1] \"data.frame\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pause.html","id":null,"dir":"Reference","previous_headings":"","what":"Pause tracking the data frame. — pause","title":"Pause tracking the data frame. — pause","text":"Pausing tracking data frame may required operation performed creates lot groupings otherwise want pollute history graph (e.g. maybe selecting something using anti-join). paused history updated resume() called, data frame ungrouped (auto enabled).","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pause.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pause tracking the data frame. — pause","text":"","code":"pause(.data, auto = FALSE)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pause.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pause tracking the data frame. — pause","text":".data tracked dataframe auto TRUE tracking resume automatically number groups fallen sensible level (default FALSE)?","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pause.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pause tracking the data frame. — pause","text":".data dataframe history graph tracking paused","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pause.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pause tracking the data frame. — pause","text":"","code":"iris %>% track() %>% pause() %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"150 items\" #> TRACKING IS PAUSED (manual)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pivot_longer.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Reshaping data using tidyr::pivot_longer — pivot_longer.trackr_df","title":"Reshaping data using tidyr::pivot_longer — pivot_longer.trackr_df","text":"drop replacement tidyr::pivot_longer() optionally takes message headline store history graph.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pivot_longer.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reshaping data using tidyr::pivot_longer — pivot_longer.trackr_df","text":"","code":"# S3 method for class 'trackr_df' pivot_longer(data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pivot_longer.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reshaping data using tidyr::pivot_longer — pivot_longer.trackr_df","text":"data data frame pivot. ... Additional arguments passed methods.   Named arguments passed tidyr::pivot_longer cols <tidy-select> Columns pivot longer format. cols_vary pivoting cols longer format, output rows arranged relative original row number? \"fastest\", default, keeps individual rows cols close together output. often produces intuitively ordered output least one key column data involved pivoting process. \"slowest\" keeps individual columns cols close together output. often produces intuitively ordered output utilize columns data pivoting process. names_to character vector specifying new column columns create information stored column names data specified cols. length 0, NULL supplied, columns created. length 1, single column created contain column names specified cols. length >1, multiple columns created. case, one names_sep names_pattern must supplied specify column names split. also two additional character values can take advantage : NA discard corresponding component column name. \".value\" indicates corresponding component column name defines name output column containing cell values, overriding values_to entirely. names_prefix regular expression used remove matching text start variable name. names_sep,names_pattern names_to contains multiple values, arguments control column name broken . names_sep takes specification separate(), can either numeric vector (specifying positions break ), single string (specifying regular expression split ). names_pattern takes specification extract(), regular expression containing matching groups (()). arguments give enough control, use pivot_longer_spec() create spec object process manually needed. names_ptypes,values_ptypes Optionally, list column name-prototype pairs. Alternatively, single empty prototype can supplied, applied columns. prototype (ptype short) zero-length vector (like integer() numeric()) defines type, class, attributes vector. Use arguments want confirm created columns types expect. Note want change (instead confirm) types specific columns, use names_transform values_transform instead. names_transform,values_transform Optionally, list column name-function pairs. Alternatively, single function can supplied, applied columns. Use arguments need change types specific columns. example, names_transform = list(week = .integer) convert character variable called week integer. specified, type columns generated names_to character, type variables generated values_to common type input columns used generate . names_repair happens output invalid column names? default, \"check_unique\" error columns duplicated. Use \"minimal\" allow duplicates output, \"unique\" de-duplicated adding numeric suffixes. See vctrs::vec_as_names() options. values_to string specifying name column create data stored cell values. names_to character containing special .value sentinel, value ignored, name value column derived part existing column names. values_drop_na TRUE, drop rows contain NAs value_to column. effectively converts explicit missing values implicit missing values, generally used missing values data created structure. .messages set glue specs. glue code can use global variable, grouping variable, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pivot_longer.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reshaping data using tidyr::pivot_longer — pivot_longer.trackr_df","text":"result tidyr::pivot_longer history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pivot_wider.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Reshaping data using tidyr::pivot_wider — pivot_wider.trackr_df","title":"Reshaping data using tidyr::pivot_wider — pivot_wider.trackr_df","text":"drop replacement tidyr::pivot_wider() optionally takes message headline store history graph.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pivot_wider.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reshaping data using tidyr::pivot_wider — pivot_wider.trackr_df","text":"","code":"# S3 method for class 'trackr_df' pivot_wider(data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pivot_wider.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reshaping data using tidyr::pivot_wider — pivot_wider.trackr_df","text":"data data frame pivot. ... Additional arguments passed methods.   Named arguments passed tidyr::pivot_wider id_cols <tidy-select> set columns uniquely identify observation. Typically used redundant variables, .e. variables whose values perfectly correlated existing variables. Defaults columns data except columns specified names_from values_from. tidyselect expression supplied, evaluated data removing columns specified names_from values_from. id_expand values id_cols columns expanded expand() pivoting? results rows, output contain complete expansion possible values id_cols. Implicit factor levels represented data become explicit. Additionally, row values corresponding expanded id_cols sorted. names_from,values_from <tidy-select> pair arguments describing column (columns) get name output column (names_from), column (columns) get cell values (values_from). values_from contains multiple values, value added front output column. names_prefix String added start every variable name. particularly useful names_from numeric vector want create syntactic variable names. names_sep names_from values_from contains multiple variables, used join values together single string use column name. names_glue Instead names_sep names_prefix, can supply glue specification uses names_from columns (special .value) create custom column names. names_sort column names sorted? FALSE, default, column names ordered first appearance. names_vary names_from identifies column (columns) multiple unique values, multiple values_from columns provided, order resulting column names combined? \"fastest\" varies names_from values fastest, resulting column naming scheme form: value1_name1, value1_name2, value2_name1, value2_name2. default. \"slowest\" varies names_from values slowest, resulting column naming scheme form: value1_name1, value2_name1, value1_name2, value2_name2. names_expand values names_from columns expanded expand() pivoting? results columns, output contain column names corresponding complete expansion possible values names_from. Implicit factor levels represented data become explicit. Additionally, column names sorted, identical names_sort produce. names_repair happens output invalid column names? default, \"check_unique\" error columns duplicated. Use \"minimal\" allow duplicates output, \"unique\" de-duplicated adding numeric suffixes. See vctrs::vec_as_names() options. values_fill Optionally, (scalar) value specifies value filled missing. can named list want apply different fill values different value columns. values_fn Optionally, function applied value cell output. typically use combination id_cols names_from columns uniquely identify observation. can named list want apply different aggregations different values_from columns. unused_fn Optionally, function applied summarize values unused columns (.e. columns identified id_cols, names_from, values_from). default drops unused columns result. can named list want apply different aggregations different unused columns. id_cols must supplied unused_fn useful, since otherwise unspecified columns considered id_cols. similar grouping id_cols summarizing unused columns using unused_fn. .messages set glue specs. glue code can use global variable, grouping variable, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/pivot_wider.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reshaping data using tidyr::pivot_wider — pivot_wider.trackr_df","text":"data dataframe result tidyr::pivot_wider function history graph updated .message requested.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/plot.trackr_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots a history graph as html — plot.trackr_graph","title":"Plots a history graph as html — plot.trackr_graph","text":"Plots history graph html","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/plot.trackr_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots a history graph as html — plot.trackr_graph","text":"","code":"# S3 method for class 'trackr_graph' plot(x, fill = \"lightgrey\", fontsize = \"8\", colour = \"black\", ...)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/plot.trackr_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots a history graph as html — plot.trackr_graph","text":"x dtrackr history graph (e.g. output history()) fill default node fill colour fontsize default font size colour default font colour ... used","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/plot.trackr_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots a history graph as html — plot.trackr_graph","text":"HTML displayed","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/plot.trackr_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots a history graph as html — plot.trackr_graph","text":"","code":"library(dplyr) library(dtrackr) iris %>% comment(\"hello {.total} rows\") %>% history() %>% plot()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/print.trackr_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a history graph to the console — print.trackr_graph","title":"Print a history graph to the console — print.trackr_graph","text":"Print history graph console","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/print.trackr_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a history graph to the console — print.trackr_graph","text":"","code":"# S3 method for class 'trackr_graph' print(x, ...)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/print.trackr_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a history graph to the console — print.trackr_graph","text":"x dtrackr history graph (e.g. output p_get()) ... used","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/print.trackr_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print a history graph to the console — print.trackr_graph","text":"nothing","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/print.trackr_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print a history graph to the console — print.trackr_graph","text":"","code":"library(dplyr) library(dtrackr) iris %>% comment(\"hello {.total} rows\") %>% history() %>% print() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"hello 150 rows\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. dplyr filter","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/reframe.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise a data set — reframe.trackr_df","title":"Summarise a data set — reframe.trackr_df","text":"Summarising data set acts normal dplyr manner collapse groups individual rows. columns resulting summary can added history graph. history also joins stratified branches allows generate summary statistics un-grouped data. See dplyr::summarise().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/reframe.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise a data set — reframe.trackr_df","text":"","code":"# S3 method for class 'trackr_df' reframe(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/reframe.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise a data set — reframe.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs summary functions. name name variable result. value can : vector length 1, e.g. min(x), n(), sum(.na(y)). data frame, add multiple columns single expression. Returning values size 0 >1 deprecated 1.1.0. Please use reframe() instead. .messages set glue specs. glue code can use summary variable defined ... parameter, global variable, {.strata} .headline headline glue spec. glue code can use summary variable defined ... parameter, global variable, {.strata} .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/reframe.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise a data set — reframe.trackr_df","text":".data dataframe summarised history graph updated showing summarise operation new stage","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/reframe.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise a data set — reframe.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% group_by(Species) %>% track() tmp %>% reframe(tibble(   param = c(\"mean\",\"min\",\"max\"),   value = c(mean(Petal.Length), min(Petal.Length), max(Petal.Length))   ), .messages=\"length {param}: {value}\") %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"length mean: 1.462\", \"length min: 1\", \"length max: 1.9\" #> ├ [Species:versicolor]: \"length mean: 4.26\", \"length min: 3\", \"length max: 5.1\" #> └ [Species:virginica]: \"length mean: 5.552\", \"length min: 4.5\", \"length max: 6.9\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/relocate.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — relocate.trackr_df","title":"dplyr modifying operations — relocate.trackr_df","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/relocate.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — relocate.trackr_df","text":"","code":"# S3 method for class 'trackr_df' relocate(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/relocate.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — relocate.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. Named arguments passed dplyr::relocate .,.<tidy-select> Destination columns selected .... Supplying neither move columns left-hand side; specifying error. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/relocate.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — relocate.trackr_df","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/relocate.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — relocate.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # relocate, this shows how the columns can be reordered iris %>%   track() %>%   group_by(Species) %>%   relocate(     tidyselect::starts_with(\"Sepal\"),     .after=Species,     .messages=\"{.cols}\",     .headline=\"Order of columns from relocate:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Order of columns from relocate:\", \"Petal.Length, Petal.Width, Species, Sepal.Length, Sepal.Width\" #> ├ [Species:versicolor]: \"Order of columns from relocate:\", \"Petal.Length, Petal.Width, Species, Sepal.Length, Sepal.Width\" #> └ [Species:virginica]: \"Order of columns from relocate:\", \"Petal.Length, Petal.Width, Species, Sepal.Length, Sepal.Width\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/rename.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — rename.trackr_df","title":"dplyr modifying operations — rename.trackr_df","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/rename.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — rename.trackr_df","text":"","code":"# S3 method for class 'trackr_df' rename(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/rename.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — rename.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. Named arguments passed dplyr::rename .fn function used transform selected .cols. return character vector length input. .cols <tidy-select> Columns rename; defaults columns. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/rename.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — rename.trackr_df","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/rename.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — rename.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # rename can show us which columns are new and which have been # removed (with .dropped_cols) iris %>%   track() %>%   group_by(Species) %>%   rename(     Stamen.Width = Sepal.Width,     Stamen.Length = Sepal.Length,     .messages=c(\"added {.new_cols}\",\"dropped {.dropped_cols}\"),     .headline=\"Renamed columns:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\" #> ├ [Species:versicolor]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\" #> └ [Species:virginica]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/rename_with.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — rename_with.trackr_df","title":"dplyr modifying operations — rename_with.trackr_df","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/rename_with.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — rename_with.trackr_df","text":"","code":"# S3 method for class 'trackr_df' rename_with(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/rename_with.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — rename_with.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. Named arguments passed dplyr::rename_with .fn function used transform selected .cols. return character vector length input. .cols <tidy-select> Columns rename; defaults columns. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/rename_with.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — rename_with.trackr_df","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/rename_with.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — rename_with.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # rename can show us which columns are new and which have been # removed (with .dropped_cols) iris %>%   track() %>%   group_by(Species) %>%   rename(     Stamen.Width = Sepal.Width,     Stamen.Length = Sepal.Length,     .messages=c(\"added {.new_cols}\",\"dropped {.dropped_cols}\"),     .headline=\"Renamed columns:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\" #> ├ [Species:versicolor]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\" #> └ [Species:virginica]: \"Renamed columns:\", \"added Stamen.Length, Stamen.Width\", \"dropped Sepal.Length, Sepal.Width\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/resume.html","id":null,"dir":"Reference","previous_headings":"","what":"Resume tracking the data frame. — resume","title":"Resume tracking the data frame. — resume","text":"may reset grouping tracked data grouping structure changed since data frame paused. try resume tracking data frame many groups (defined options(\"dtrackr.max_supported_groupings\"=XX)) resume fail data frame still paused. can overridden specifying value .maxgroups parameter.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/resume.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resume tracking the data frame. — resume","text":"","code":"resume(.data, ...)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/resume.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resume tracking the data frame. — resume","text":".data tracked dataframe ... Named arguments passed p_group_by .messages set glue specs. glue code can use global variable, {.cols} columns grouped . .headline headline glue spec. glue code can use global variable, {.cols}. .tag want summary data step future give name .tag. .maxgroups maximum number subgroups allowed tracking paused. ... group_by(), variables computations group . Computations always done ungrouped data frame. perform computations grouped data, need use separate mutate() step group_by(). Computations allowed nest_by(). ungroup(), variables remove grouping.   Named arguments passed dplyr::group_by .add FALSE, default, group_by() override existing groups. add existing groups, use .add = TRUE. argument previously called add, prevented creating new grouping variable called add, conflicts naming conventions. .drop Drop groups formed factor levels appear data? default TRUE except .data previously grouped .drop = FALSE. See group_by_drop_default() details. x tbl()","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/resume.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resume tracking the data frame. — resume","text":".data data frame history graph tracking resumed","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/resume.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Resume tracking the data frame. — resume","text":"","code":"library(dplyr) library(dtrackr) iris %>% track() %>% pause() %>% resume() %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"150 items\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/right_join.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Right join — right_join.trackr_df","title":"Right join — right_join.trackr_df","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::right_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/right_join.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Right join — right_join.trackr_df","text":"","code":"# S3 method for class 'trackr_df' right_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\",     \"{.count.out} in linked set\"),   .headline = \"Right join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/right_join.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Right join — right_join.trackr_df","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::right_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . suffix non-joined duplicate variables x y, suffixes added output disambiguate . character vector length 2. keep join keys x y preserved output? NULL, default, joins equality retain keys x, joins inequality retain keys inputs. TRUE, keys inputs retained. FALSE, keys x retained. right full joins, data key columns corresponding rows exist y merged key columns x. used joining inequality conditions. na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). multiple Handling rows x multiple matches y. row x: \"\", default, returns every match detected y. behavior SQL. \"\" returns one match detected y, guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected y. \"last\" returns last match detected y. unmatched unmatched keys result dropped rows handled? \"drop\" drops unmatched keys result. \"error\" throws error unmatched keys detected. unmatched intended protect accidentally dropping rows join. checks unmatched keys input potentially drop rows. left joins, checks y. right joins, checks x. inner joins, checks x y. case, unmatched also allowed character vector length 2 specify behavior x y independently. relationship Handling expected relationship keys x y. expectations chosen list invalidated, error thrown. NULL, default, expect relationship x y. However, equality joins check many--many relationship (typically unexpected) warn one occurs, encouraging either take closer look inputs make relationship explicit specifying \"many--many\". See Many--many relationships section details. \"one--one\" expects: row x matches 1 row y. row y matches 1 row x. \"one--many\" expects: row y matches 1 row x. \"many--one\" expects: row x matches 1 row y. \"many--many\" perform relationship checks, provided allow explicit relationship know exists. relationship handle cases zero matches. , see unmatched. .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/right_join.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Right join — right_join.trackr_df","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/right_join.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Right join — right_join.trackr_df","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Full join join = lhs %>% full_join(rhs, by=\"name\", multiple = \"all\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 173\" nrow(join) #> [1] 173 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/save_dot.html","id":null,"dir":"Reference","previous_headings":"","what":"Save DOT content to a file — save_dot","title":"Save DOT content to a file — save_dot","text":"Convert digraph dot format SVG save range output file types","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/save_dot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save DOT content to a file — save_dot","text":"","code":"save_dot(   dot,   filename,   size = std_size$half,   maxWidth = size$width,   maxHeight = size$height,   formats = c(\"dot\", \"png\", \"pdf\", \"svg\"),   landscape = size$rot != 0,   ... )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/save_dot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save DOT content to a file — save_dot","text":"dot graphviz dot string filename full path file name (minus extension multiple formats) size named list 3 elements, length width inches rotation. predefined set standard sizes available std_size object. maxWidth width (paper) inches size defined maxHeight height (paper) inches size defined formats pdf,dot,svg,png,ps landscape rotate output 270 degrees landscape format. maxWidth maxHeight still apply refer paper width fit flowchart rotation. (might need flip width height) ... ignored","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/save_dot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save DOT content to a file — save_dot","text":"list items paths absolute paths saved files named list, svg SVG string rendered dot file.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/save_dot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save DOT content to a file — save_dot","text":"","code":"save_dot(\"digraph {A->B}\",tempfile()) #> $paths #> $paths$dot #> [1] \"/tmp/Rtmpk04qY6/file150ff31be2a77.dot\" #>  #> $paths$png #> [1] \"/tmp/Rtmpk04qY6/file150ff31be2a77.png\" #>  #> $paths$pdf #> [1] \"/tmp/Rtmpk04qY6/file150ff31be2a77.pdf\" #>  #> $paths$svg #> [1] \"/tmp/Rtmpk04qY6/file150ff31be2a77.svg\" #>  #>  #> $svg #> [1] \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\"\\n \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\\n<!-- Generated by graphviz version 2.40.1 (20161225.0304)\\n -->\\n<!-- Title: %0 Pages: 1 -->\\n<svg width=\\\"62.000pt\\\" height=\\\"116.000pt\\\"\\n viewBox=\\\"0 0 62.000 116.000\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">\\n<g id=\\\"graph0\\\" class=\\\"graph\\\" transform=\\\"scale(1.000 1.000) rotate(0) translate(4 112.000)\\\">\\n<title>%0<\/title>\\n<polygon fill=\\\"#ffffff\\\" stroke=\\\"transparent\\\" points=\\\"-4,4 -4,-112 58,-112 58,4 -4,4\\\"/>\\n<!-- A -->\\n<g id=\\\"node1\\\" class=\\\"node\\\">\\n<title>A<\/title>\\n<ellipse fill=\\\"none\\\" stroke=\\\"#000000\\\" cx=\\\"27\\\" cy=\\\"-90\\\" rx=\\\"27\\\" ry=\\\"18\\\"/>\\n<text text-anchor=\\\"middle\\\" x=\\\"27\\\" y=\\\"-85.8\\\" font-family=\\\"Times,serif\\\" font-size=\\\"14.00\\\" fill=\\\"#000000\\\">A<\/text>\\n<\/g>\\n<!-- B -->\\n<g id=\\\"node2\\\" class=\\\"node\\\">\\n<title>B<\/title>\\n<ellipse fill=\\\"none\\\" stroke=\\\"#000000\\\" cx=\\\"27\\\" cy=\\\"-18\\\" rx=\\\"27\\\" ry=\\\"18\\\"/>\\n<text text-anchor=\\\"middle\\\" x=\\\"27\\\" y=\\\"-13.8\\\" font-family=\\\"Times,serif\\\" font-size=\\\"14.00\\\" fill=\\\"#000000\\\">B<\/text>\\n<\/g>\\n<!-- A&#45;&gt;B -->\\n<g id=\\\"edge1\\\" class=\\\"edge\\\">\\n<title>A&#45;&gt;B<\/title>\\n<path fill=\\\"none\\\" stroke=\\\"#000000\\\" d=\\\"M27,-71.8314C27,-64.131 27,-54.9743 27,-46.4166\\\"/>\\n<polygon fill=\\\"#000000\\\" stroke=\\\"#000000\\\" points=\\\"30.5001,-46.4132 27,-36.4133 23.5001,-46.4133 30.5001,-46.4132\\\"/>\\n<\/g>\\n<\/g>\\n<\/svg>\\n\" #>"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/select.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — select.trackr_df","title":"dplyr modifying operations — select.trackr_df","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/select.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — select.trackr_df","text":"","code":"# S3 method for class 'trackr_df' select(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/select.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — select.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/select.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — select.trackr_df","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/select.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — select.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # select # The output of the select verb (here using tidyselect syntax) can be captured # and here all column names are being reported with the .cols variable. iris %>%   track() %>%   group_by(Species) %>%   select(     tidyselect::starts_with(\"Sepal\"),     .messages=\"{.cols}\",     .headline=\"Output columns from select:\") %>%   history() #> Adding missing grouping variables: `Species` #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Output columns from select:\", \"Species, Sepal.Length, Sepal.Width\" #> ├ [Species:versicolor]: \"Output columns from select:\", \"Species, Sepal.Length, Sepal.Width\" #> └ [Species:virginica]: \"Output columns from select:\", \"Species, Sepal.Length, Sepal.Width\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/semi_join.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi join — semi_join.trackr_df","title":"Semi join — semi_join.trackr_df","text":"Mutating joins behave dplyr joins, except history graph two sides joins merged resulting tracked dataframe history input dataframes. See dplyr::semi_join() details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/semi_join.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi join — semi_join.trackr_df","text":"","code":"# S3 method for class 'trackr_df' semi_join(   x,   y,   ...,   .messages = c(\"{.count.lhs} on LHS\", \"{.count.rhs} on RHS\",     \"{.count.out} in intersection\"),   .headline = \"Semi join by {.keys}\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/semi_join.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi join — semi_join.trackr_df","text":"x, y pair data frames, data frame extensions (e.g. tibble), lazy data frames (e.g. dbplyr dtplyr). See Methods, , details. ... parameters passed onto methods.   Named arguments passed dplyr::semi_join join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy TRUE, y copied src x.  allows join tables across srcs, potentially expensive operation must opt . na_matches two NA two NaN values match? \"na\", default, treats two NA two NaN values equal, like %%, match(), merge(). \"never\" treats two NA two NaN values different, never match together values. similar joins database sources base::merge(incomparables = NA). .messages set glue specs. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively .headline glue spec. glue code can use global variable, {.keys} joining columns, {.count.lhs}, {.count.rhs}, {.count.} input output dataframes sizes respectively","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/semi_join.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi join — semi_join.trackr_df","text":"join two dataframes history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/semi_join.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi join — semi_join.trackr_df","text":"","code":"library(dplyr) library(dtrackr) # Joins across data sets  # example data uses the dplyr starways data people = starwars %>% select(-films, -vehicles, -starships) films = starwars %>% select(name,films) %>% tidyr::unnest(cols = c(films))  lhs = people %>% track() %>% comment(\"People df {.total}\") rhs = films %>% track() %>% comment(\"Films df {.total}\") %>%   comment(\"a test comment\")  # Semi join join = lhs %>% semi_join(rhs, by=\"name\") %>% comment(\"joined {.total}\") # See what the history of the graph is: join %>% history() %>% print() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"joined 87\" nrow(join) #> [1] 87 # Display the tracked graph (not run in examples) # join %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/setdiff.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — setdiff.trackr_df","title":"Set operations — setdiff.trackr_df","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/setdiff.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — setdiff.trackr_df","text":"","code":"# S3 method for class 'trackr_df' setdiff(   x,   y,   ...,   .messages = \"{.count.out} items in difference\",   .headline = \"Difference\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/setdiff.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — setdiff.trackr_df","text":"x, y Vectors combine. ... collection tracked data frames combine .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/setdiff.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — setdiff.trackr_df","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/setdiff.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — setdiff.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — slice.trackr_df","title":"Slice operations — slice.trackr_df","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — slice.trackr_df","text":"","code":"# S3 method for class 'trackr_df' slice(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — slice.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — slice.trackr_df","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — slice.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # an arbitrary 50 items from the iris dataframe is selected. The # history is tracked iris %>% track() %>% slice(51:100) %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"slice data\", \"150 before\", \"50 after\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_head.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — slice_head.trackr_df","title":"Slice operations — slice_head.trackr_df","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_head.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — slice_head.trackr_df","text":"","code":"# S3 method for class 'trackr_df' slice_head(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_head.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — slice_head.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice_head ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_head.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — slice_head.trackr_df","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_head.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — slice_head.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # the first 50% of the data frame, is taken and the history tracked iris %>% track() %>% group_by(Species) %>%   slice_head(prop=0.5,.messages=\"{.count.out} / {.count.in}\",              .headline=\"First {sprintf('%1.0f',prop*100)}%\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"First 50%\", \"25 / 50\" #> ├ [Species:versicolor]: \"First 50%\", \"25 / 50\" #> └ [Species:virginica]: \"First 50%\", \"25 / 50\"  # The last 100 items: iris %>% track() %>% group_by(Species) %>%   slice_tail(n=100,.messages=\"{.count.out} / {.count.in}\",              .headline=\"Last 100\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Last 100\", \"50 / 50\" #> ├ [Species:versicolor]: \"Last 100\", \"50 / 50\" #> └ [Species:virginica]: \"Last 100\", \"50 / 50\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_max.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — slice_max.trackr_df","title":"Slice operations — slice_max.trackr_df","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_max.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — slice_max.trackr_df","text":"","code":"# S3 method for class 'trackr_df' slice_max(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_max.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — slice_max.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice_max ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_max.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — slice_max.trackr_df","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_max.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — slice_max.trackr_df","text":"","code":"library(dplyr) library(dtrackr)   # Subset the data by the maximum of a given value iris %>% track() %>% group_by(Species) %>%   slice_max(prop=0.5, order_by = Sepal.Width,             .messages=\"{.count.out} / {.count.in} = {prop} (with ties)\",             .headline=\"Widest 50% Sepals\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Widest 50% Sepals\", \"31 / 50 = 0.5 (with ties)\" #> ├ [Species:versicolor]: \"Widest 50% Sepals\", \"29 / 50 = 0.5 (with ties)\" #> └ [Species:virginica]: \"Widest 50% Sepals\", \"29 / 50 = 0.5 (with ties)\"   # The narrowest 25% of the iris data set by group can be calculated in the # slice_min() function. Recording this is a matter of tracking and # using glue specs. iris %>%   track() %>%   group_by(Species) %>%   slice_min(prop=0.25, order_by = Sepal.Width,             .messages=\"{.count.out} / {.count.in} (with ties)\",             .headline=\"narrowest {sprintf('%1.0f',prop*100)}% {Species}\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"narrowest 25% setosa\", \"12 / 50 (with ties)\" #> ├ [Species:versicolor]: \"narrowest 25% versicolor\", \"13 / 50 (with ties)\" #> └ [Species:virginica]: \"narrowest 25% virginica\", \"19 / 50 (with ties)\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_min.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — slice_min.trackr_df","title":"Slice operations — slice_min.trackr_df","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_min.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — slice_min.trackr_df","text":"","code":"# S3 method for class 'trackr_df' slice_min(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_min.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — slice_min.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice_min ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_min.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — slice_min.trackr_df","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_min.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — slice_min.trackr_df","text":"","code":"library(dplyr) library(dtrackr)   # Subset the data by the maximum of a given value iris %>% track() %>% group_by(Species) %>%   slice_max(prop=0.5, order_by = Sepal.Width,             .messages=\"{.count.out} / {.count.in} = {prop} (with ties)\",             .headline=\"Widest 50% Sepals\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Widest 50% Sepals\", \"31 / 50 = 0.5 (with ties)\" #> ├ [Species:versicolor]: \"Widest 50% Sepals\", \"29 / 50 = 0.5 (with ties)\" #> └ [Species:virginica]: \"Widest 50% Sepals\", \"29 / 50 = 0.5 (with ties)\"   # The narrowest 25% of the iris data set by group can be calculated in the # slice_min() function. Recording this is a matter of tracking and # using glue specs. iris %>%   track() %>%   group_by(Species) %>%   slice_min(prop=0.25, order_by = Sepal.Width,             .messages=\"{.count.out} / {.count.in} (with ties)\",             .headline=\"narrowest {sprintf('%1.0f',prop*100)}% {Species}\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"narrowest 25% setosa\", \"12 / 50 (with ties)\" #> ├ [Species:versicolor]: \"narrowest 25% versicolor\", \"13 / 50 (with ties)\" #> └ [Species:virginica]: \"narrowest 25% virginica\", \"19 / 50 (with ties)\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_sample.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — slice_sample.trackr_df","title":"Slice operations — slice_sample.trackr_df","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_sample.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — slice_sample.trackr_df","text":"","code":"# S3 method for class 'trackr_df' slice_sample(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_sample.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — slice_sample.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice_sample ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_sample.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — slice_sample.trackr_df","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_sample.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — slice_sample.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # In this example the iris dataframe is resampled 100 times with replacement # within each group and the iris %>%   track() %>%   group_by(Species) %>%   slice_sample(n=100, replace=TRUE,                .messages=\"{.count.out} / {.count.in} = {n}\",                .headline=\"100 {Species}\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"100 setosa\", \"100 / 50 = 100\" #> ├ [Species:versicolor]: \"100 versicolor\", \"100 / 50 = 100\" #> └ [Species:virginica]: \"100 virginica\", \"100 / 50 = 100\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_tail.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice operations — slice_tail.trackr_df","title":"Slice operations — slice_tail.trackr_df","text":"Slice operations behave dplyr, except history graph can updated tracked dataframe sizes dataframe. See dplyr::slice(), dplyr::slice_head(), dplyr::slice_tail(), dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(), details underlying functions.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_tail.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice operations — slice_tail.trackr_df","text":"","code":"# S3 method for class 'trackr_df' slice_tail(   .data,   ...,   .messages = c(\"{.count.in} before\", \"{.count.out} after\"),   .headline = \"slice data\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_tail.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice operations — slice_tail.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... slice(): <data-masking> Integer row values. Provide either positive values keep, negative values drop. values provided must either positive negative. Indices beyond number rows input silently ignored. slice_*(), arguments passed methods.   Named arguments passed dplyr::slice_tail ., <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve Relevant .data input grouped. .preserve = FALSE (default), grouping structure recalculated based resulting data, otherwise grouping kept . n,prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. prop rounded towards zero generate integer number rows. negative value n prop subtracted group size. example, n = -2 group 5 rows select 5 - 2 = 3 rows; prop = -0.25 8 rows select 8 * (1 - 0.25) = 6 rows. order_by <data-masking> Variable function variables order . order multiple variables, wrap data frame tibble. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by <data-masking> Sampling weights. must evaluate vector non-negative numbers length input. Weights automatically standardised sum 1. replace sampling performed (TRUE) without (FALSE, default) replacement. .messages set glue specs. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively {.excluded} difference .headline glue spec. glue code can use global variable, {.count.}, {.count.} input output dataframes sizes respectively.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_tail.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice operations — slice_tail.trackr_df","text":"sliced dataframe history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/slice_tail.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice operations — slice_tail.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # the first 50% of the data frame, is taken and the history tracked iris %>% track() %>% group_by(Species) %>%   slice_head(prop=0.5,.messages=\"{.count.out} / {.count.in}\",              .headline=\"First {sprintf('%1.0f',prop*100)}%\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"First 50%\", \"25 / 50\" #> ├ [Species:versicolor]: \"First 50%\", \"25 / 50\" #> └ [Species:virginica]: \"First 50%\", \"25 / 50\"  # The last 100 items: iris %>% track() %>% group_by(Species) %>%   slice_tail(n=100,.messages=\"{.count.out} / {.count.in}\",              .headline=\"Last 100\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Last 100\", \"50 / 50\" #> ├ [Species:versicolor]: \"Last 100\", \"50 / 50\" #> └ [Species:virginica]: \"Last 100\", \"50 / 50\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/status.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a summary to the dtrackr history graph — status","title":"Add a summary to the dtrackr history graph — status","text":"middle pipeline may wish document something data complex simple counts. status essentially dplyr summarisation step connected glue specification output, recorded data frame history. means can arbitrary interim summarisation put result flowchart without disrupting pipeline flow.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a summary to the dtrackr history graph — status","text":"","code":"status(   .data,   ...,   .messages = .defaultMessage(),   .headline = .defaultHeadline(),   .type = \"info\",   .asOffshoot = FALSE,   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a summary to the dtrackr history graph — status","text":".data dataframe may grouped ... normal dplyr::summarise specification, e.g. count=n() av=mean(x), etcetera. .messages character vector glue specifications. glue specification can refer summary outputs, grouping variables .data, {.strata}, variables defined calling environment .headline glue specification can refer grouping variables .data, variables defined calling environment .type one \"info\",\"exclusion\": used define formatting .asOffshoot want comment offshoot main flow (default = FALSE). .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a summary to the dtrackr history graph — status","text":".data dataframe history metadata updated status inserted new stage","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/status.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a summary to the dtrackr history graph — status","text":"... summary specification parameters MUST NAMED.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/status.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a summary to the dtrackr history graph — status","text":"","code":"library(dplyr) library(dtrackr) tmp = iris %>% track() %>% group_by(Species) tmp %>% status(       long = p_count_if(Petal.Length>5),       short = p_count_if(Petal.Length<2),       .messages=\"{Species}: {long} long ones & {short} short ones\" ) %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"Species:setosa\", \"setosa: 0 long ones &amp; 50 short ones\" #> ├ [Species:versicolor]: \"Species:versicolor\", \"versicolor: 1 long ones &amp; 0 short ones\" #> └ [Species:virginica]: \"Species:virginica\", \"virginica: 41 long ones &amp; 0 short ones\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/std_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Standard paper sizes — std_size","title":"Standard paper sizes — std_size","text":"list standard paper sizes outputting flowcharts dot graphs. include width height dimensions inches can used one way specify output size dot graph, including flowcharts (see size parameter flowchart()).","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/std_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standard paper sizes — std_size","text":"","code":"std_size"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/std_size.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Standard paper sizes — std_size","text":"object class list length 12.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/std_size.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Standard paper sizes — std_size","text":"sizes available A4, A5, full (fits portrait A4 margins), half (half A4 margins), third, two_third, quarter, sixth (reference A4 page margins). 2 landscape sizes A4_landscape full_landscape fit A4 page without margins. also 2 slide dimensions, fit standard presentation software dimensions. just convenience. Similar effects can achieved providing width height parameters flowchart() directly.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/summarise.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise a data set — summarise.trackr_df","title":"Summarise a data set — summarise.trackr_df","text":"Summarising data set acts normal dplyr manner collapse groups individual rows. columns resulting summary can added history graph. history also joins stratified branches allows generate summary statistics un-grouped data. See dplyr::summarise().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/summarise.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise a data set — summarise.trackr_df","text":"","code":"# S3 method for class 'trackr_df' summarise(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/summarise.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise a data set — summarise.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs summary functions. name name variable result. value can : vector length 1, e.g. min(x), n(), sum(.na(y)). data frame, add multiple columns single expression. Returning values size 0 >1 deprecated 1.1.0. Please use reframe() instead. .messages set glue specs. glue code can use summary variable defined ... parameter, global variable, {.strata} .headline headline glue spec. glue code can use summary variable defined ... parameter, global variable, {.strata} .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/summarise.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise a data set — summarise.trackr_df","text":".data dataframe summarised history graph updated showing summarise operation new stage","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/summarise.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise a data set — summarise.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% group_by(Species) %>% track() tmp %>% summarise(avg = mean(Petal.Length), .messages=\"{avg} length\") %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"1.462 length\" #> ├ [Species:versicolor]: \"4.26 length\" #> └ [Species:virginica]: \"5.552 length\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/tagged.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve tagged data in the history graph — tagged","title":"Retrieve tagged data in the history graph — tagged","text":"counts individual stages stored .tag option pipeline step can recovered . idea provide quick way access single value counts details tagged pipeline format can reported text document. (e.g. results section). examples consort statement vignette examples use.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/tagged.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve tagged data in the history graph — tagged","text":"","code":"tagged(.data, .tag = NULL, .strata = NULL, .glue = NULL, ...)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/tagged.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve tagged data in the history graph — tagged","text":".data tracked dataframe. .tag (optional) tag retrieve. .strata (optional) filter tagged data strata. set \"\" filter just top level ungrouped data. .glue (optional) glue specification applied tagged content generate .label tagged content. ... (optional) named parameters passed glue::glue can used generate label.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/tagged.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve tagged data in the history graph — tagged","text":"various things depending requested. default tibble .tag column associated summary values nested .content column. .strata column specified results filtered just match given .strata grouping (.e. grouping label flowchart). Ungrouped content empty \"\" .strata .tag specified result single tag .content automatically un-nested give single un-nested dataframe content captured .tag tagged step. single multiple rows depending whether original data grouped point tagging. .tag .glue specified .label column computed .glue tagged content. result single row just string value .label returned. just .glue specified, un-nested dataframe .tag,.strata .label columns label tag strata. seems complex best thing experiment get output want, leaving .glue options think know . made sense time.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/tagged.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve tagged data in the history graph — tagged","text":"","code":"library(dplyr) library(dtrackr) tmp = iris %>% track() %>% comment(.tag = \"step1\") tmp = tmp %>% filter(Species!=\"versicolor\") %>% group_by(Species) tmp %>% comment(.tag=\"step2\") %>% tagged(.glue = \"{.count}/{.total}\") #> # A tibble: 3 × 3 #>   .tag  .strata             .label  #>   <chr> <chr>               <glue>  #> 1 step1 \"\"                  150/150 #> 2 step2 \"Species:setosa\"    50/100  #> 3 step2 \"Species:virginica\" 50/100"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/track.html","id":null,"dir":"Reference","previous_headings":"","what":"Start tracking the dtrackr history graph — track","title":"Start tracking the dtrackr history graph — track","text":"Start tracking dtrackr history graph","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/track.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Start tracking the dtrackr history graph — track","text":"","code":"track(   .data,   .messages = .defaultMessage(),   .headline = .defaultHeadline(),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/track.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Start tracking the dtrackr history graph — track","text":".data dataframe may grouped .messages character vector glue specifications. glue specification can refer grouping variables .data, variables defined calling environment, {.total} variable count rows, {.count} variable count rows current group {.strata} describes current group. Defaults value getOption(\"dtrackr.default_message\"). .headline glue specification can refer grouping variables .data, variables defined calling environment, {.total} variable nrow(.data), {.strata} summary current group. Defaults value getOption(\"dtrackr.default_headline\"). .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/track.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Start tracking the dtrackr history graph — track","text":".data dataframe additional history graph metadata, allow tracking.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/track.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Start tracking the dtrackr history graph — track","text":"","code":"library(dplyr) library(dtrackr) iris %>% track() %>% history() #> dtrackr history: #> number of flowchart steps: 1 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"150 items\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/transmute.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr modifying operations — transmute.trackr_df","title":"dplyr modifying operations — transmute.trackr_df","text":"See dplyr::mutate(), dplyr::add_count(), dplyr::add_tally(), dplyr::transmute(), dplyr::select(), dplyr::relocate(), dplyr::rename() dplyr::rename_with(), dplyr::arrange() details underlying functions. dtrackr provides equivalent functions mutating, selecting renaming data set act way dplyr. mutate / select / rename generally add anything terms provenance data default behaviour miss dtrackr history. can overridden .messages, .headline values case behave just like comment().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/transmute.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr modifying operations — transmute.trackr_df","text":"","code":"# S3 method for class 'trackr_df' transmute(.data, ..., .messages = \"\", .headline = \"\", .tag = NULL)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/transmute.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr modifying operations — transmute.trackr_df","text":".data data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). See Methods, , details. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. .messages set glue specs. glue code can use global variable, grouping variable, {.new_cols} {.dropped_cols} changes columns, {.cols} output column names, {.strata}. Defaults nothing. .headline headline glue spec. glue code can use global variable, grouping variable, {.new_cols}, {.dropped_cols}, {.cols} {.strata}. Defaults nothing. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/transmute.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dplyr modifying operations — transmute.trackr_df","text":".data dataframe modified dplyr equivalent function, history graph updated new stage .messages .headline parameter empty.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/transmute.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr modifying operations — transmute.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # mutate and other functions are unitary operations that generally change # the structure but not size of a dataframe. In dtrackr these are by ignored # by default but we can change that so that their behaviour is obvious.  # In this example we compare the column names of the input and the # output to identify the new columns created by the transmute operation as # the `.new_cols` variable # Here we do the same for a transmute() iris %>%   track() %>%   group_by(Species, .add=TRUE) %>%   transmute(     sepal.w = Sepal.Width-1,     sepal.l = Sepal.Length+1,     .messages=\"{.new_cols}\",     .headline=\"New columns from transmute:\") %>%   history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> ├ [Species:setosa]: \"New columns from transmute:\", \"sepal.w, sepal.l\" #> ├ [Species:versicolor]: \"New columns from transmute:\", \"sepal.w, sepal.l\" #> └ [Species:virginica]: \"New columns from transmute:\", \"sepal.w, sepal.l\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/ungroup.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove a stratification from a data set — ungroup.trackr_df","title":"Remove a stratification from a data set — ungroup.trackr_df","text":"Un-grouping data set logically combines different arms. history joins stratified branches acts specific type status(), allowing generate summary statistics un-grouped data. See dplyr::ungroup().","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/ungroup.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove a stratification from a data set — ungroup.trackr_df","text":"","code":"# S3 method for class 'trackr_df' ungroup(   x,   ...,   .messages = .defaultMessage(),   .headline = .defaultHeadline(),   .tag = NULL )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/ungroup.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove a stratification from a data set — ungroup.trackr_df","text":"x tbl() ... variables remove grouping. .messages set glue specs. glue code can use global variable, {.count}. default \"total {.count} items\" .headline headline glue spec. glue code can use {.count} {.strata}. .tag want summary data step future give name .tag.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/ungroup.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove a stratification from a data set — ungroup.trackr_df","text":".data dataframe ungrouped history graph updated showing ungroup operation new stage.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/ungroup.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove a stratification from a data set — ungroup.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  tmp = iris %>% group_by(Species) %>% comment(\"A test\") tmp %>% ungroup(.messages=\"{.count} items in combined\") %>% history() #> dtrackr history: #> number of flowchart steps: 2 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"150 items in combined\""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/union.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — union.trackr_df","title":"Set operations — union.trackr_df","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/union.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — union.trackr_df","text":"","code":"# S3 method for class 'trackr_df' union(   x,   y,   ...,   .messages = \"{.count.out} unique items in union\",   .headline = \"Distinct union\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/union.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — union.trackr_df","text":"x, y Vectors combine. ... collection tracked data frames combine .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/union.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — union.trackr_df","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/union.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — union.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/union_all.trackr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — union_all.trackr_df","title":"Set operations — union_all.trackr_df","text":"perform set operations tracked dataframes. merges history 2 () dataframes combines rows (columns). calculates total number resulting rows {.count.} terms performs exactly operation equivalent dplyr operation. See dplyr::bind_rows(), dplyr::bind_cols(), dplyr::intersect(), dplyr::union(), dplyr::setdiff(),dplyr::intersect(), dplyr::union_all() underlying function details.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/union_all.trackr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — union_all.trackr_df","text":"","code":"# S3 method for class 'trackr_df' union_all(   x,   y,   ...,   .messages = \"{.count.out} items in union\",   .headline = \"Union\" )"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/union_all.trackr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — union_all.trackr_df","text":"x, y Pair compatible data frames. pair data frames compatible column names (possibly different orders) compatible types. ... collection tracked data frames combine .messages set glue specs. glue code can use global variable, {.count.} .headline glue spec. glue code can use global variable, {.count.}","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/union_all.trackr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — union_all.trackr_df","text":"dplyr output history graph updated.","code":""},{"path":[]},{"path":"https://terminological.github.io/dtrackr/index.html/reference/union_all.trackr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — union_all.trackr_df","text":"","code":"library(dplyr) library(dtrackr)  # Set operations people = starwars %>% select(-films, -vehicles, -starships) chrs = people %>% track(\"start\")  lhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Droid\" ~ \"{.included} droids\" )  # these are different subsets of the same data rhs = chrs %>% include_any(   species == \"Human\" ~ \"{.included} humans\",   species == \"Gungan\" ~ \"{.included} gungans\" ) %>% comment(\"{.count} gungans & humans\")   # Unions set = bind_rows(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 3 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  set = union(lhs,rhs) %>% comment(\"{.count} human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"44 human,droids and gungans\" nrow(set) #> [1] 44 # not run - display the flowchart: # set %>% flowchart()  set = union_all(lhs,rhs) %>% comment(\"{.count} 2*human,droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"79 2*human,droids and gungans\" nrow(set) #> [1] 79 # not run - display the flowchart: # set %>% flowchart()  # Intersections and differences  set = setdiff(lhs,rhs) %>% comment(\"{.count} droids and gungans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"6 droids and gungans\" nrow(set) #> [1] 6 # not run - display the flowchart: # set %>% flowchart()  set = intersect(lhs,rhs) %>% comment(\"{.count} humans\") # display the history of the result: set %>% history() #> dtrackr history: #> number of flowchart steps: 5 (approx) #> tags defined: <none> #> items excluded so far: <not capturing exclusions> #> last entry / entries: #> └ \"35 humans\" nrow(set) #> [1] 35 # not run - display the flowchart: # set %>% flowchart()"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/untrack.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove tracking from the dataframe — untrack","title":"Remove tracking from the dataframe — untrack","text":"Remove tracking dataframe","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/untrack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove tracking from the dataframe — untrack","text":"","code":"untrack(.data)"},{"path":"https://terminological.github.io/dtrackr/index.html/reference/untrack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove tracking from the dataframe — untrack","text":".data tracked dataframe","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/untrack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove tracking from the dataframe — untrack","text":".data dataframe history graph metadata removed.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/reference/untrack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove tracking from the dataframe — untrack","text":"","code":"library(dplyr) library(dtrackr) iris %>% track() %>% untrack() %>% class() #> [1] \"data.frame\""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-046","dir":"Changelog","previous_headings":"","what":"dtrackr 0.4.6","title":"dtrackr 0.4.6","text":"fixed un-escaped braces documentation CRAN. documentation fixes","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-044","dir":"Changelog","previous_headings":"","what":"dtrackr 0.4.4","title":"dtrackr 0.4.4","text":"CRAN release: 2023-09-04 Support reframe alternative summarise dplyr 1.1.0 remove tidyverse suggests dependency. TODO: (future version) exclusions joins TODO: (future version) better support long format dataframes TODO: (future version) column level tracking (prototyped 0.2.5)","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-043","dir":"Changelog","previous_headings":"","what":"dtrackr 0.4.3","title":"dtrackr 0.4.3","text":"fixed warnings caused additional deprecated dplyr functions. informative messages syntactic errors exclude_all include_any input fixed regression bug pivot_wider documentation updates. improved ranking nodes branching groups.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-042","dir":"Changelog","previous_headings":"","what":"dtrackr 0.4.2","title":"dtrackr 0.4.2","text":"updates remove deprecation warnings dplyr 1.1.0 change information warnings switched default. auto resume paused tracking dataframes","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-041","dir":"Changelog","previous_headings":"","what":"dtrackr 0.4.1","title":"dtrackr 0.4.1","text":"Regression bug fix group_by results multiple group nodes. improved testing group_by functions removal extraneous ungroup node rearranging grouping structure.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-040","dir":"Changelog","previous_headings":"","what":"dtrackr 0.4.0","title":"dtrackr 0.4.0","text":"CRAN release: 2023-03-24 Updating release following dplyr version 1.1.0 changes new versions tidyr use @inheritDotParams decouple upstream APIs fix #33 Fix RSVG scaling inconsistency / rotation issues.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-030","dir":"Changelog","previous_headings":"","what":"dtrackr 0.3.0","title":"dtrackr 0.3.0","text":"Updating release preparation dplyr version 1.1.0 Fix problems detected URLs DOI. Updated URL: https://terminological.github.io/dtrackr https://terminological.github.io/dtrackr/ readme README.md (fixed missing trailing slash) Manually fixed auto-generated codecov badge. Removed project level Zenodo DOI triggering invalid DOI CRAN Updated maintainer email longer term stable email address. URLs DESCRIPTION updated point github source. spelling issues arise documentation inherited dplyrand tidyr equivalent functions, need fixed upstream. Documentation inherited dplyr may inconsistent dplyr release.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-025","dir":"Changelog","previous_headings":"","what":"dtrackr 0.2.5","title":"dtrackr 0.2.5","text":"updates following JOSS review: changes documentation resulted additional Suggests dependencies CRAN packages. bug fix group_by checking pause status warning pause required. documentation improvements - full review documentation. Additional context function reference draw attention supported dplyr operations added nest_join.tracked_df S3 method, added slice*.tracked_df functions, missing set operations functions. re-factored mutate style operations, regression tested automated testing new methods, full testing slice, set ops, mutate style functions new example code. expanded test coverage ( covr::package_coverage(type=\"\" ): dtrackr Coverage: 83.60%, R/dot.R: 78.12%, R/dtrackr.R: 84.08%) mostly examples improved error handling reporting mutate functions. bug #25 & #26 fixes (see github) Logo documentation fixes improvements. outstanding issues: re-use documentation results examples tests running multiple times.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-024","dir":"Changelog","previous_headings":"","what":"dtrackr 0.2.4","title":"dtrackr 0.2.4","text":"CRAN release: 2022-07-05 second round fixes CRAN. Improved examples documentation. Print plot S3 methods history graph. Vignette fixes. Non breaking changes API bumping new minor version CRAN submission.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-023","dir":"Changelog","previous_headings":"","what":"dtrackr 0.2.3","title":"dtrackr 0.2.3","text":"documentation updates & JOSS paper fix fix multiple names join columns bug. ungroup() change fit dplyr::ungroup API. fixed url redirects, DESCRIPTION file issues switched LICENSE file template, CRAN submission.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-022","dir":"Changelog","previous_headings":"","what":"dtrackr 0.2.2","title":"dtrackr 0.2.2","text":"new feature subgroup counts determining size subgroups grouped (un-grouped) flowchart. fix multiple names join columns bug. bug fixes extended github workflows.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-021","dir":"Changelog","previous_headings":"","what":"dtrackr 0.2.1","title":"dtrackr 0.2.1","text":"minor bug fixes grouping support tagging pipeline piece data later retrieval support e.g. counts within abstract support tidyselect syntax group ","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-020","dir":"Changelog","previous_headings":"","what":"dtrackr 0.2.0","title":"dtrackr 0.2.0","text":"track excluded items debugging info allow across syntax situations (except group_by) support pausing un-pausing dataframe tracking preventing massive group_by groups large numbers small groups selected (e.g. part group_by() %>% mutate()) switch warnings rlang::warn etc.","code":""},{"path":"https://terminological.github.io/dtrackr/index.html/news/index.html","id":"dtrackr-0109000---pre-release-github-version","dir":"Changelog","previous_headings":"","what":"dtrackr 0.1.0.9000 - pre-release github version","title":"dtrackr 0.1.0.9000 - pre-release github version","text":"Initial package features complete dplyr like like functionality supporting - add_count, add_tally, anti_join, arrange, bind_rows, comment, distinct, exclude_all, filter, full_join, group_by, group_modify, inner_join, left_join, mutate, pivot_longer, pivot_wider, relocate, rename, rename_with, right_join, select, semi_join, summarise, transmute, ungroup add comment history (stratified grouping), add status history (stratified grouping), apply exclusion inclusion filters including stratified commentary merge histories joining data frames export history dot graphviz graph render history graph SVG, PNG, PDF, DOT PS formats","code":""}]
